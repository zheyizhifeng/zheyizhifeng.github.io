<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+Simplified+Chinese:300,300italic,400,400italic,700,700italic%7CCousine:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/green/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zheyizhifeng.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/db.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="来自网道项目，原文 点这里查看   简介Bash 是 Unix 系统和 Linux 系统的一种 Shell（命令行环境），是目前绝大多数 Linux 发行版的默认 Shell。 Shell 的含义学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。 具体来说，Shell 这个词有多种">
<meta property="og:type" content="article">
<meta property="og:title" content="Bash 脚本教程">
<meta property="og:url" content="https://zheyizhifeng.github.io/2021/10/12/Bash%20%E8%84%9A%E6%9C%AC%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="Lucida&#39;s Blog">
<meta property="og:description" content="来自网道项目，原文 点这里查看   简介Bash 是 Unix 系统和 Linux 系统的一种 Shell（命令行环境），是目前绝大多数 Linux 发行版的默认 Shell。 Shell 的含义学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。 具体来说，Shell 这个词有多种">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-10-12T09:36:37.000Z">
<meta property="article:modified_time" content="2021-10-14T08:05:32.287Z">
<meta property="article:author" content="lucida">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Bash">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zheyizhifeng.github.io/2021/10/12/Bash%20%E8%84%9A%E6%9C%AC%E6%95%99%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zheyizhifeng.github.io/2021/10/12/Bash%20%E8%84%9A%E6%9C%AC%E6%95%99%E7%A8%8B/","path":"2021/10/12/Bash 脚本教程/","title":"Bash 脚本教程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Bash 脚本教程 | Lucida's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Lucida's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">41</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">15</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">22</span></a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Shell-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">Shell 的含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shell-%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">Shell 的种类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">1.3.</span> <span class="nav-text">命令行环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF%E6%A8%A1%E6%8B%9F%E5%99%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">终端模拟器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%90%E7%A4%BA%E7%AC%A6"><span class="nav-number">1.3.2.</span> <span class="nav-text">命令行提示符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E5%92%8C%E9%80%80%E5%87%BA%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.3.</span> <span class="nav-text">进入和退出方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shell-%E5%92%8C-Bash-%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="nav-number">1.4.</span> <span class="nav-text">Shell 和 Bash 的历史</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#echo-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.1.</span> <span class="nav-text">echo 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#n%E5%8F%82%E6%95%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">-n参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#e%E5%8F%82%E6%95%B0"><span class="nav-number">2.1.2.</span> <span class="nav-text">-e参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">命令格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E6%A0%BC"><span class="nav-number">2.3.</span> <span class="nav-text">空格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8F%B7"><span class="nav-number">2.4.</span> <span class="nav-text">分号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E7%9A%84%E7%BB%84%E5%90%88%E7%AC%A6-amp-amp-%E5%92%8C"><span class="nav-number">2.5.</span> <span class="nav-text">命令的组合符&amp;&amp;和||</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.6.</span> <span class="nav-text">type 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="nav-number">2.7.</span> <span class="nav-text">快捷键</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">3.</span> <span class="nav-text">模式扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number">3.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A2%E6%B5%AA%E7%BA%BF%E6%89%A9%E5%B1%95"><span class="nav-number">3.2.</span> <span class="nav-text">波浪线扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%89%A9%E5%B1%95"><span class="nav-number">3.3.</span> <span class="nav-text">? 字符扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%89%A9%E5%B1%95-1"><span class="nav-number">3.4.</span> <span class="nav-text">* 字符扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%8B%AC%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="nav-number">3.5.</span> <span class="nav-text">方括号扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#start-end-%E6%89%A9%E5%B1%95"><span class="nav-number">3.6.</span> <span class="nav-text">[start-end] 扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="nav-number">3.7.</span> <span class="nav-text">大括号扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#start-end-%E6%89%A9%E5%B1%95-1"><span class="nav-number">3.8.</span> <span class="nav-text">{start..end} 扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%89%A9%E5%B1%95"><span class="nav-number">3.9.</span> <span class="nav-text">变量扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E5%91%BD%E4%BB%A4%E6%89%A9%E5%B1%95"><span class="nav-number">3.10.</span> <span class="nav-text">子命令扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E6%89%A9%E5%B1%95"><span class="nav-number">3.11.</span> <span class="nav-text">算术扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="nav-number">3.12.</span> <span class="nav-text">字符类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">3.13.</span> <span class="nav-text">使用注意点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8F%E8%AF%8D%E8%AF%AD%E6%B3%95"><span class="nav-number">3.14.</span> <span class="nav-text">量词语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shopt-%E5%91%BD%E4%BB%A4"><span class="nav-number">3.15.</span> <span class="nav-text">shopt 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">3.16.</span> <span class="nav-text">参考链接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E5%8F%B7%E5%92%8C%E8%BD%AC%E4%B9%89"><span class="nav-number">4.</span> <span class="nav-text">引号和转义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89"><span class="nav-number">4.1.</span> <span class="nav-text">转义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%BC%95%E5%8F%B7"><span class="nav-number">4.2.</span> <span class="nav-text">单引号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%BC%95%E5%8F%B7"><span class="nav-number">4.3.</span> <span class="nav-text">双引号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Here-%E6%96%87%E6%A1%A3"><span class="nav-number">4.4.</span> <span class="nav-text">Here 文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Here-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.5.</span> <span class="nav-text">Here 字符串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bash-%E5%8F%98%E9%87%8F"><span class="nav-number">5.</span> <span class="nav-text">Bash 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-number">5.1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">5.1.1.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="nav-number">5.1.2.</span> <span class="nav-text">自定义变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F"><span class="nav-number">5.2.</span> <span class="nav-text">创建变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%8F%98%E9%87%8F"><span class="nav-number">5.3.</span> <span class="nav-text">读取变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%8F%98%E9%87%8F"><span class="nav-number">5.4.</span> <span class="nav-text">删除变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E5%8F%98%E9%87%8F%EF%BC%8Cexport-%E5%91%BD%E4%BB%A4"><span class="nav-number">5.5.</span> <span class="nav-text">输出变量，export 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F"><span class="nav-number">5.6.</span> <span class="nav-text">特殊变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">5.7.</span> <span class="nav-text">变量的默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#declare-%E5%91%BD%E4%BB%A4"><span class="nav-number">5.8.</span> <span class="nav-text">declare 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#readonly-%E5%91%BD%E4%BB%A4"><span class="nav-number">5.9.</span> <span class="nav-text">readonly 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#let-%E5%91%BD%E4%BB%A4"><span class="nav-number">5.10.</span> <span class="nav-text">let 命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="nav-number">6.</span> <span class="nav-text">字符串操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">6.1.</span> <span class="nav-text">字符串的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">6.2.</span> <span class="nav-text">子字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="nav-number">6.3.</span> <span class="nav-text">搜索和替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="nav-number">6.4.</span> <span class="nav-text">改变大小写</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="nav-number">7.</span> <span class="nav-text">算术运算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">7.1.</span> <span class="nav-text">算术表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E8%BF%9B%E5%88%B6"><span class="nav-number">7.2.</span> <span class="nav-text">数值的进制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">7.3.</span> <span class="nav-text">位运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="nav-number">7.4.</span> <span class="nav-text">逻辑运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="nav-number">7.5.</span> <span class="nav-text">赋值运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E5%80%BC%E8%BF%90%E7%AE%97"><span class="nav-number">7.6.</span> <span class="nav-text">求值运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#expr-%E5%91%BD%E4%BB%A4"><span class="nav-number">7.7.</span> <span class="nav-text">expr 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#let-%E5%91%BD%E4%BB%A4-1"><span class="nav-number">7.8.</span> <span class="nav-text">let 命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">8.</span> <span class="nav-text">行操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="nav-number">8.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8"><span class="nav-number">8.2.</span> <span class="nav-text">光标移动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E5%B1%8F%E5%B9%95"><span class="nav-number">8.3.</span> <span class="nav-text">清除屏幕</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E6%93%8D%E4%BD%9C"><span class="nav-number">8.4.</span> <span class="nav-text">编辑操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="nav-number">8.5.</span> <span class="nav-text">自动补全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%8E%86%E5%8F%B2"><span class="nav-number">8.6.</span> <span class="nav-text">操作历史</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">8.6.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#history-%E5%91%BD%E4%BB%A4"><span class="nav-number">8.6.2.</span> <span class="nav-text">history 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="nav-number">8.6.3.</span> <span class="nav-text">相关快捷键</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="nav-number">8.7.</span> <span class="nav-text">其他快捷键</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E5%A0%86%E6%A0%88"><span class="nav-number">9.</span> <span class="nav-text">目录堆栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cd"><span class="nav-number">9.1.</span> <span class="nav-text">cd -</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pushd%EF%BC%8Cpopd"><span class="nav-number">9.2.</span> <span class="nav-text">pushd，popd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dirs-%E5%91%BD%E4%BB%A4"><span class="nav-number">9.3.</span> <span class="nav-text">dirs 命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8"><span class="nav-number">10.</span> <span class="nav-text">脚本入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Shebang-%E8%A1%8C"><span class="nav-number">10.1.</span> <span class="nav-text">Shebang 行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90%E5%92%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">10.2.</span> <span class="nav-text">执行权限和路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#env-%E5%91%BD%E4%BB%A4"><span class="nav-number">10.3.</span> <span class="nav-text">env 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">10.4.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E5%8F%82%E6%95%B0"><span class="nav-number">10.5.</span> <span class="nav-text">脚本参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shift-%E5%91%BD%E4%BB%A4"><span class="nav-number">10.6.</span> <span class="nav-text">shift 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getopts-%E5%91%BD%E4%BB%A4"><span class="nav-number">10.7.</span> <span class="nav-text">getopts 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E9%A1%B9%E5%8F%82%E6%95%B0%E7%BB%88%E6%AD%A2%E7%AC%A6"><span class="nav-number">10.8.</span> <span class="nav-text">配置项参数终止符 --</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exit-%E5%91%BD%E4%BB%A4"><span class="nav-number">10.9.</span> <span class="nav-text">exit 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="nav-number">10.10.</span> <span class="nav-text">命令执行结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#source-%E5%91%BD%E4%BB%A4"><span class="nav-number">10.11.</span> <span class="nav-text">source 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%AB%E5%90%8D%EF%BC%8Calias-%E5%91%BD%E4%BB%A4"><span class="nav-number">10.12.</span> <span class="nav-text">别名，alias 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-1"><span class="nav-number">10.13.</span> <span class="nav-text">参考链接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#read-%E5%91%BD%E4%BB%A4"><span class="nav-number">11.</span> <span class="nav-text">read 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">11.1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0"><span class="nav-number">11.2.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IFS-%E5%8F%98%E9%87%8F"><span class="nav-number">11.3.</span> <span class="nav-text">IFS 变量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">12.</span> <span class="nav-text">条件判断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#if-%E7%BB%93%E6%9E%84"><span class="nav-number">12.1.</span> <span class="nav-text">if 结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#test-%E5%91%BD%E4%BB%A4"><span class="nav-number">12.2.</span> <span class="nav-text">test 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">12.3.</span> <span class="nav-text">判断表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">12.3.1.</span> <span class="nav-text">文件判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E6%96%AD"><span class="nav-number">12.3.2.</span> <span class="nav-text">字符串判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%88%A4%E6%96%AD"><span class="nav-number">12.3.3.</span> <span class="nav-text">整数判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E5%88%A4%E6%96%AD"><span class="nav-number">12.3.4.</span> <span class="nav-text">正则判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test-%E5%88%A4%E6%96%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="nav-number">12.3.5.</span> <span class="nav-text">test 判断的逻辑运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E5%88%A4%E6%96%AD"><span class="nav-number">12.3.6.</span> <span class="nav-text">算术判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%91%BD%E4%BB%A4%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="nav-number">12.3.7.</span> <span class="nav-text">普通命令的逻辑运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#case-%E7%BB%93%E6%9E%84"><span class="nav-number">12.4.</span> <span class="nav-text">case 结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-2"><span class="nav-number">12.5.</span> <span class="nav-text">参考链接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">13.</span> <span class="nav-text">循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="nav-number">13.1.</span> <span class="nav-text">while 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#until-%E5%BE%AA%E7%8E%AF"><span class="nav-number">13.2.</span> <span class="nav-text">until 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for%E2%80%A6in-%E5%BE%AA%E7%8E%AF"><span class="nav-number">13.3.</span> <span class="nav-text">for…in 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">13.4.</span> <span class="nav-text">for 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#break%EF%BC%8Ccontinue"><span class="nav-number">13.5.</span> <span class="nav-text">break，continue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select-%E7%BB%93%E6%9E%84"><span class="nav-number">13.6.</span> <span class="nav-text">select 结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-3"><span class="nav-number">13.7.</span> <span class="nav-text">参考链接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">14.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="nav-number">14.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F"><span class="nav-number">14.2.</span> <span class="nav-text">参数变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#return-%E5%91%BD%E4%BB%A4"><span class="nav-number">14.3.</span> <span class="nav-text">return 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8Clocal-%E5%91%BD%E4%BB%A4"><span class="nav-number">14.4.</span> <span class="nav-text">全局变量和局部变量，local 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-4"><span class="nav-number">14.5.</span> <span class="nav-text">参考链接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">15.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="nav-number">15.1.</span> <span class="nav-text">创建数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E7%BB%84"><span class="nav-number">15.2.</span> <span class="nav-text">读取数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%8D%95%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">15.2.1.</span> <span class="nav-text">读取单个元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%89%80%E6%9C%89%E6%88%90%E5%91%98"><span class="nav-number">15.2.2.</span> <span class="nav-text">读取所有成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E4%BD%8D%E7%BD%AE"><span class="nav-number">15.2.3.</span> <span class="nav-text">默认位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">15.3.</span> <span class="nav-text">数组的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E5%8F%96%E6%95%B0%E7%BB%84%E5%BA%8F%E5%8F%B7"><span class="nav-number">15.4.</span> <span class="nav-text">提取数组序号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E5%8F%96%E6%95%B0%E7%BB%84%E6%88%90%E5%91%98"><span class="nav-number">15.5.</span> <span class="nav-text">提取数组成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0%E6%95%B0%E7%BB%84%E6%88%90%E5%91%98"><span class="nav-number">15.6.</span> <span class="nav-text">追加数组成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84"><span class="nav-number">15.7.</span> <span class="nav-text">删除数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84"><span class="nav-number">15.8.</span> <span class="nav-text">关联数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#set-%E5%91%BD%E4%BB%A4%EF%BC%8Cshopt-%E5%91%BD%E4%BB%A4"><span class="nav-number">16.</span> <span class="nav-text">set 命令，shopt 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="nav-number">16.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-u"><span class="nav-number">16.2.</span> <span class="nav-text">set -u</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-x"><span class="nav-number">16.3.</span> <span class="nav-text">set -x</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">16.4.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-e"><span class="nav-number">16.5.</span> <span class="nav-text">set -e</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-o-pipefail"><span class="nav-number">16.6.</span> <span class="nav-text">set -o pipefail</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-E"><span class="nav-number">16.7.</span> <span class="nav-text">set -E</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0"><span class="nav-number">16.8.</span> <span class="nav-text">其他参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93"><span class="nav-number">16.9.</span> <span class="nav-text">set 命令总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shopt-%E5%91%BD%E4%BB%A4-1"><span class="nav-number">16.10.</span> <span class="nav-text">shopt 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-5"><span class="nav-number">16.11.</span> <span class="nav-text">参考链接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E9%99%A4%E9%94%99"><span class="nav-number">17.</span> <span class="nav-text">脚本除错</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="nav-number">17.1.</span> <span class="nav-text">常见错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bash%E7%9A%84-x%E5%8F%82%E6%95%B0"><span class="nav-number">17.2.</span> <span class="nav-text">bash的-x参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-1"><span class="nav-number">17.3.</span> <span class="nav-text">环境变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LINENO"><span class="nav-number">17.3.1.</span> <span class="nav-text">LINENO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FUNCNAME"><span class="nav-number">17.3.2.</span> <span class="nav-text">FUNCNAME</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BASH-SOURCE"><span class="nav-number">17.3.3.</span> <span class="nav-text">BASH_SOURCE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BASH-LINENO"><span class="nav-number">17.3.4.</span> <span class="nav-text">BASH_LINENO</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mktemp-%E5%91%BD%E4%BB%A4%EF%BC%8Ctrap-%E5%91%BD%E4%BB%A4"><span class="nav-number">18.</span> <span class="nav-text">mktemp 命令，trap 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">18.1.</span> <span class="nav-text">临时文件的安全问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mktemp-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">18.2.</span> <span class="nav-text">mktemp 命令的用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mktemp-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">18.3.</span> <span class="nav-text">mktemp 命令的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#trap-%E5%91%BD%E4%BB%A4"><span class="nav-number">18.4.</span> <span class="nav-text">trap 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-6"><span class="nav-number">18.5.</span> <span class="nav-text">参考链接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E7%8E%AF%E5%A2%83"><span class="nav-number">19.</span> <span class="nav-text">启动环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Session"><span class="nav-number">19.1.</span> <span class="nav-text">Session</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%99%BB%E5%BD%95-Session"><span class="nav-number">19.1.1.</span> <span class="nav-text">登录 Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%99%BB%E5%BD%95-Session"><span class="nav-number">19.1.2.</span> <span class="nav-text">非登录 Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bash-logout"><span class="nav-number">19.1.3.</span> <span class="nav-text">.bash_logout</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9"><span class="nav-number">19.2.</span> <span class="nav-text">启动选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%AE%E7%9B%98%E7%BB%91%E5%AE%9A"><span class="nav-number">19.3.</span> <span class="nav-text">键盘绑定</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6"><span class="nav-number">20.</span> <span class="nav-text">命令提示符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-PS1"><span class="nav-number">20.1.</span> <span class="nav-text">环境变量 PS1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2"><span class="nav-number">20.2.</span> <span class="nav-text">颜色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-PS2%EF%BC%8CPS3%EF%BC%8CPS4"><span class="nav-number">20.3.</span> <span class="nav-text">环境变量 PS2，PS3，PS4</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lucida"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">lucida</p>
  <div class="site-description" itemprop="description">文质彬彬，然后君子</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zheyizhifeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zheyizhifeng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zheyizhifeng@126.com" title="E-Mail → mailto:zheyizhifeng@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/zheyizhifeng" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;zheyizhifeng" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/zheyizhifeng" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;zheyizhifeng" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/zheyizhifeng" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;zheyizhifeng" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="skype:zheyizhifeng?call|chat" title="Skype → skype:zheyizhifeng?call|chat" rel="noopener" target="_blank"><i class="fab fa-skype fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/zheyizhifeng" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zheyizhifeng.github.io/2021/10/12/Bash%20%E8%84%9A%E6%9C%AC%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="lucida">
      <meta itemprop="description" content="文质彬彬，然后君子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lucida's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Bash 脚本教程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-12 17:36:37" itemprop="dateCreated datePublished" datetime="2021-10-12T17:36:37+08:00">2021-10-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-14 16:05:32" itemprop="dateModified" datetime="2021-10-14T16:05:32+08:00">2021-10-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>来自网道项目，原文 <a target="_blank" rel="noopener" href="https://wangdoc.com/bash/">点这里查看</a> </p>
<hr>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Bash 是 Unix 系统和 Linux 系统的一种 Shell（命令行环境），是目前绝大多数 Linux 发行版的默认 Shell。</p>
<h2 id="Shell-的含义"><a href="#Shell-的含义" class="headerlink" title="Shell 的含义"></a>Shell 的含义</h2><p>学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p>
<p>具体来说，Shell 这个词有多种含义。</p>
<a id="more"></a>
<p>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（command line interface，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。<br>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。</p>
<p>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p>
<h2 id="Shell-的种类"><a href="#Shell-的种类" class="headerlink" title="Shell 的种类"></a>Shell 的种类</h2><p>Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell。</p>
<p>历史上，主要的 Shell 有下面这些。</p>
<ul>
<li>Bourne Shell（sh）</li>
<li>Bourne Again shell（bash）</li>
<li>C Shell（csh）</li>
<li>TENEX C Shell（tcsh）</li>
<li>Korn shell（ksh）</li>
<li>Z Shell（zsh）</li>
<li>Friendly Interactive Shell（fish）</li>
</ul>
<p>Bash 是目前最常用的 Shell，除非特别指明，下文的 Shell 和 Bash 当作同义词使用，可以互换。</p>
<p>下面的命令可以查看当前运行的 Shell。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$SHELL</span>
/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>下面的命令可以查看当前的 Linux 系统安装的所有 Shell。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /etc/shells<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面两个命令中，<code>$</code>是命令行环境的提示符，用户只需要输入提示符后面的内容。</p>
<p>Linux 允许每个用户使用不同的 Shell，用户的默认 Shell 一般都是 Bash，或者与 Bash 兼容。</p>
<h2 id="命令行环境"><a href="#命令行环境" class="headerlink" title="命令行环境"></a>命令行环境</h2><h3 id="终端模拟器"><a href="#终端模拟器" class="headerlink" title="终端模拟器"></a>终端模拟器</h3><p>如果是不带有图形环境的 Linux 系统（比如专用于服务器的系统），启动后就直接是命令行环境。</p>
<p>不过，现在大部分的 Linux 发行版，尤其是针对普通用户的发行版，都是图形环境。用户登录系统后，自动进入图形环境，需要自己启动终端模拟器，才能进入命令行环境。</p>
<p>所谓“终端模拟器”（terminal emulator）就是一个模拟命令行窗口的程序，让用户在一个窗口中使用命令行环境，并且提供各种附加功能，比如调整颜色、字体大小、行距等等。</p>
<p>不同 Linux 发行版（准确地说是不同的桌面环境）带有的终端程序是不一样的，比如 KDE 桌面环境的终端程序是 konsole，Gnome 桌面环境的终端程序是 gnome-terminal，用户也可以安装第三方的终端程序。所有终端程序，尽管名字不同，基本功能都是一样的，就是让用户可以进入命令行环境，使用 Shell。</p>
<h3 id="命令行提示符"><a href="#命令行提示符" class="headerlink" title="命令行提示符"></a>命令行提示符</h3><p>进入命令行环境以后，用户会看到 Shell 的提示符。提示符往往是一串前缀，最后以一个美元符号<code>$</code>结尾，用户可以在这个符号后面输入各种命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user@hostname<span class="token punctuation">]</span> $<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，完整的提示符是<code>[user@hostname] $</code>，其中前缀是用户名（<code>user</code>）加上<code>@</code>，再加主机名（<code>hostname</code>）。比如，用户名是<code>bill</code>，主机名是<code>home-machine</code>，前缀就是<code>bill@home-machine</code>。</p>
<p>注意，根用户（root）的提示符，不以美元符号（<code>$</code>）结尾，而以井号（<code>#</code>）结尾，用来提醒用户，现在具有根权限，可以执行各种操作，务必小心，不要出现误操作。这个符号是可以自己定义的，详见《命令提示符》一章。</p>
<p>为了简洁，后文的命令行提示符都只使用<code>$</code>表示。</p>
<h3 id="进入和退出方法"><a href="#进入和退出方法" class="headerlink" title="进入和退出方法"></a>进入和退出方法</h3><p>进入命令行环境以后，一般就已经打开 Bash 了。如果你的 Shell 不是 Bash，可以输入<code>bash</code>命令启动 Bash。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>退出 Bash 环境，可以使用<code>exit</code>命令，也可以同时按下<code>Ctrl + d</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Bash 的基本用法就是在命令行输入各种命令，非常直观。作为练习，可以试着输入<code>pwd</code>命令。按下回车键，就会显示当前所在的目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">pwd</span>
/home/me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果不小心输入了<code>pwe</code>，会返回一个提示，表示输入出错，没有对应的可执行程序。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pwe
bash: pwe：未找到命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="Shell-和-Bash-的历史"><a href="#Shell-和-Bash-的历史" class="headerlink" title="Shell 和 Bash 的历史"></a>Shell 和 Bash 的历史</h2><p>Shell 伴随着 Unix 系统的诞生而诞生。</p>
<p>1969年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。</p>
<p>1971年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是<code>sh</code>，方便用户使用 Unix。</p>
<p>1973年至1975年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。</p>
<p>1976年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。</p>
<p>1978年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是<code>csh</code>。它是第一个真正替代<code>sh</code>的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。</p>
<p>1979年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是<code>sh</code>。对于用户来说，它们是同一个东西，只是底层代码不同而已。</p>
<p>1983年，David Korn 开发了Korn shell，程序名是<code>ksh</code>。</p>
<p>1985年，Richard Stallman 成立了自由软件基金会（FSF），由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。</p>
<p>1988年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为<code>bash</code>，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。</p>
<p>1989年，Bash 发布1.0版。</p>
<p>1996年，Bash 发布2.0版。</p>
<p>2004年，Bash 发布3.0版。</p>
<p>2009年，Bash 发布4.0版。</p>
<p>2019年，Bash 发布5.0版。</p>
<p>用户可以通过<code>bash</code>命令的<code>--version</code>参数或者环境变量<code>$BASH_VERSION</code>，查看本机的 Bash 版本。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> --version
GNU bash，版本 <span class="token number">5.0</span>.3<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>-release <span class="token punctuation">(</span>x86_64-pc-linux-gnu<span class="token punctuation">)</span>

<span class="token comment"># 或者</span>
$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$BASH_VERSION</span>
<span class="token number">5.0</span>.3<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>-release<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>本章介绍 Bash 的最基本语法。</p>
<h2 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a>echo 命令</h2><p>由于后面的例子会大量用到<code>echo</code>命令，这里先介绍这个命令。</p>
<p><code>echo</code>命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> hello world
hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，<code>echo</code>的参数是<code>hello world</code>，可以原样输出。</p>
<p>如果想要输出的是多行文本，即包括换行符。这时就需要把多行文本放在引号里面。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"&lt;HTML>
    &lt;HEAD>
          &lt;TITLE>Page Title&lt;/TITLE>
    &lt;/HEAD>
    &lt;BODY>
          Page body.
    &lt;/BODY>
&lt;/HTML>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>echo</code>可以原样输出多行文本。</p>
<h3 id="n参数"><a href="#n参数" class="headerlink" title="-n参数"></a><code>-n</code>参数</h3><p>默认情况下，<code>echo</code>输出的文本末尾会有一个回车符。<code>-n</code>参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> -n hello world
hello world$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，<code>world</code>后面直接就是下一行的提示符<code>$</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> a<span class="token punctuation">;</span><span class="token builtin class-name">echo</span> b
a
b

$ <span class="token builtin class-name">echo</span> -n a<span class="token punctuation">;</span><span class="token builtin class-name">echo</span> b
ab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>-n</code>参数可以让两个<code>echo</code>命令的输出连在一起，出现在同一行。</p>
<h3 id="e参数"><a href="#e参数" class="headerlink" title="-e参数"></a><code>-e</code>参数</h3><p><code>-e</code>参数会解释引号（双引号和单引号）里面的特殊字符（比如换行符<code>\n</code>）。如果不使用<code>-e</code>参数，即默认情况下，引号会让特殊字符变成普通字符，<code>echo</code>不解释它们，原样输出。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"Hello<span class="token entity" title="\n">\n</span>World"</span>
Hello<span class="token punctuation">\</span>nWorld

<span class="token comment"># 双引号的情况</span>
$ <span class="token builtin class-name">echo</span> -e <span class="token string">"Hello<span class="token entity" title="\n">\n</span>World"</span>
Hello
World

<span class="token comment"># 单引号的情况</span>
$ <span class="token builtin class-name">echo</span> -e <span class="token string">'Hello<span class="token entity" title="\n">\n</span>World'</span>
Hello
World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>-e</code>参数使得<code>\n</code>解释为换行符，导致输出内容里面出现换行。</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">command</span> <span class="token punctuation">[</span> arg1 <span class="token punctuation">..</span>. <span class="token punctuation">[</span> argN <span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面代码中，<code>command</code>是具体的命令或者一个可执行文件，<code>arg1 ... argN</code>是传递给命令的参数，它们是可选的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面这个命令中，<code>ls</code>是命令，<code>-l</code>是参数。</p>
<p>有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如上面的<code>-l</code>。同一个配置项往往有长和短两种形式，比如<code>-l</code>是短形式，<code>--list</code>是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 短形式</span>
$ <span class="token function">ls</span> -r

<span class="token comment"># 长形式</span>
$ <span class="token function">ls</span> --reverse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面命令中，<code>-r</code>是短形式，<code>--reverse</code>是长形式，作用完全一样。前者便于输入，后者便于理解。</p>
<p>Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> foo bar

<span class="token comment"># 等同于</span>
$ <span class="token builtin class-name">echo</span> foo <span class="token punctuation">\</span>
bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>Bash 使用空格（或 Tab 键）区分不同的参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">command</span> foo bar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令中，<code>foo</code>和<code>bar</code>之间有一个空格，所以 Bash 认为它们是两个参数。</p>
<p>如果参数之间有多个空格，Bash 会自动忽略多余的空格。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> this is a     <span class="token builtin class-name">test</span>
this is a <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面命令中，<code>a</code>和<code>test</code>之间有多个空格，Bash 会忽略多余的空格。</p>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>分号（<code>;</code>）是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">clear</span><span class="token punctuation">;</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，Bash 先执行<code>clear</code>命令，执行完成后，再执行<code>ls</code>命令。</p>
<p>注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。</p>
<h2 id="命令的组合符-amp-amp-和"><a href="#命令的组合符-amp-amp-和" class="headerlink" title="命令的组合符&amp;&amp;和||"></a>命令的组合符<code>&amp;&amp;</code>和<code>||</code></h2><p>除了分号，Bash 还提供两个命令组合符<code>&amp;&amp;</code>和<code>||</code>，允许更好地控制多个命令之间的继发关系。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command1 <span class="token operator">&amp;&amp;</span> Command2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令的意思是，如果<code>Command1</code>命令运行成功，则继续运行<code>Command2</code>命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command1 <span class="token operator">||</span> Command2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令的意思是，如果<code>Command1</code>命令运行失败，则继续运行<code>Command2</code>命令。</p>
<p>下面是一些例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> filelist.txt <span class="token punctuation">;</span> <span class="token function">ls</span> -l filelist.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，只要<code>cat</code>命令执行结束，不管成功或失败，都会继续执行<code>ls</code>命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> filelist.txt <span class="token operator">&amp;&amp;</span> <span class="token function">ls</span> -l filelist.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，只有<code>cat</code>命令执行成功，才会继续执行<code>ls</code>命令。如果<code>cat</code>执行失败（比如不存在文件<code>flielist.txt</code>），那么<code>ls</code>命令就不会执行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> foo <span class="token operator">||</span> <span class="token function">mkdir</span> bar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，只有<code>mkdir foo</code>命令执行失败（比如<code>foo</code>目录已经存在），才会继续执行<code>mkdir bar</code>命令。如果<code>mkdir foo</code>命令执行成功，就不会创建<code>bar</code>目录了。</p>
<h2 id="type-命令"><a href="#type-命令" class="headerlink" title="type 命令"></a>type 命令</h2><p>Bash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢？</p>
<p><code>type</code>命令用来判断命令的来源。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">type</span> <span class="token builtin class-name">echo</span>
<span class="token builtin class-name">echo</span> is a shell <span class="token builtin class-name">builtin</span>
$ <span class="token builtin class-name">type</span> <span class="token function">ls</span>
<span class="token function">ls</span> is hashed <span class="token punctuation">(</span>/bin/ls<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>type</code>命令告诉我们，<code>echo</code>是内部命令，<code>ls</code>是外部程序（<code>/bin/ls</code>）。</p>
<p><code>type</code>命令本身也是内置命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">type</span> <span class="token builtin class-name">type</span>
<span class="token builtin class-name">type</span> is a shell <span class="token builtin class-name">builtin</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果要查看一个命令的所有定义，可以使用<code>type</code>命令的<code>-a</code>参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">type</span> -a <span class="token builtin class-name">echo</span>
<span class="token builtin class-name">echo</span> is shell <span class="token builtin class-name">builtin</span>
<span class="token builtin class-name">echo</span> is /usr/bin/echo
<span class="token builtin class-name">echo</span> is /bin/echo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码表示，<code>echo</code>命令既是内置命令，也有对应的外部程序。</p>
<p><code>type</code>命令的<code>-t</code>参数，可以返回一个命令的类型：别名（alias），关键词（keyword），函数（function），内置命令（builtin）和文件（file）。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">type</span> -t <span class="token function">bash</span>
<span class="token function">file</span>
$ <span class="token builtin class-name">type</span> -t <span class="token keyword">if</span>
keyword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>bash</code>是文件，<code>if</code>是关键词。</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>Bash 提供很多快捷键，可以大大方便操作。下面是一些最常用的快捷键，完整的介绍参见《行操作》一章。</p>
<ul>
<li><code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部。</li>
<li><code>Ctrl + C</code>：中止当前正在执行的命令。</li>
<li><code>Shift + PageUp</code>：向上滚动。</li>
<li><code>Shift + PageDown</code>：向下滚动。</li>
<li><code>Ctrl + U</code>：从光标位置删除到行首。</li>
<li><code>Ctrl + K</code>：从光标位置删除到行尾。</li>
<li><code>Ctrl + D</code>：关闭 Shell 会话。</li>
<li><code>↑</code>，<code>↓</code>：浏览已执行命令的历史记录。</li>
</ul>
<p>除了上面的快捷键，Bash 还具有自动补全功能。命令输入到一半的时候，可以按下 Tab 键，Bash 会自动完成剩下的部分。比如，输入<code>pw</code>，然后按一下 Tab 键，Bash 会自动补上<code>d</code>。</p>
<p>除了命令的自动补全，Bash 还支持路径的自动补全。有时，需要输入很长的路径，这时只需要输入前面的部分，然后按下 Tab 键，就会自动补全后面的部分。如果有多个可能的选择，按两次 Tab 键，Bash 会显示所有选项，让你选择。</p>
<h1 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。</p>
<p>这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。Bash 一共提供八种扩展。</p>
<ul>
<li>波浪线扩展</li>
<li><code>?</code> 字符扩展</li>
<li><code>*</code> 字符扩展</li>
<li>方括号扩展</li>
<li>大括号扩展</li>
<li>变量扩展</li>
<li>子命令扩展</li>
<li>算术扩展</li>
</ul>
<p>本章介绍这八种扩展。</p>
<p>Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。</p>
<p>模块扩展的英文单词是<code>globbing</code>，这个词来自于早期的 Unix 系统有一个<code>/etc/glob</code>文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。</p>
<p>模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。</p>
<p>Bash 允许用户关闭扩展。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">set</span> -o noglob
<span class="token comment"># 或者</span>
$ <span class="token builtin class-name">set</span> -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>下面的命令可以重新打开扩展。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">set</span> +o noglob
<span class="token comment"># 或者</span>
$ <span class="token builtin class-name">set</span> +f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="波浪线扩展"><a href="#波浪线扩展" class="headerlink" title="波浪线扩展"></a>波浪线扩展</h2><p>波浪线<code>~</code>会自动扩展成当前用户的主目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> ~
/home/me<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>~/dir</code>表示扩展成主目录的某个子目录，<code>dir</code>是主目录里面的一个子目录名。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 进入 /home/me/foo 目录</span>
$ <span class="token builtin class-name">cd</span> ~/foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>~user</code>表示扩展成用户<code>user</code>的主目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> ~foo
/home/foo

$ <span class="token builtin class-name">echo</span> ~root
/root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。</p>
<p>如果<code>~user</code>的<code>user</code>是不存在的用户名，则波浪号扩展不起作用。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> ~nonExistedUser
~nonExistedUser<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>~+</code>会扩展成当前所在的目录，等同于<code>pwd</code>命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> ~/foo
$ <span class="token builtin class-name">echo</span> ~+
/home/me/foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="字符扩展"><a href="#字符扩展" class="headerlink" title="? 字符扩展"></a><code>?</code> 字符扩展</h2><p><code>?</code>字符代表文件路径里面的任意单个字符，不包括空字符。比如，<code>Data???</code>匹配所有<code>Data</code>后面跟着三个字符的文件名。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 存在文件 a.txt 和 b.txt</span>
$ <span class="token function">ls</span> ?.txt
a.txt b.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面命令中，<code>?</code>表示单个字符，所以会同时匹配<code>a.txt</code>和<code>b.txt</code>。</p>
<p>如果匹配多个字符，就需要多个<code>?</code>连用。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span class="token function">ls</span> ??.txt
ab.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面命令中，<code>??</code>匹配了两个字符。</p>
<p><code>?</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 当前目录有 a.txt 文件</span>
$ <span class="token builtin class-name">echo</span> ?.txt
a.txt

<span class="token comment"># 当前目录为空目录</span>
$ <span class="token builtin class-name">echo</span> ?.txt
?.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，如果<code>?.txt</code>可以扩展成文件名，<code>echo</code>命令会输出扩展后的结果；如果不能扩展成文件名，<code>echo</code>就会原样输出<code>?.txt</code>。</p>
<h2 id="字符扩展-1"><a href="#字符扩展-1" class="headerlink" title="* 字符扩展"></a><code>*</code> 字符扩展</h2><p><code>*</code>字符代表文件路径里面的任意数量的任意字符，包括零个字符。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span class="token function">ls</span> *.txt
a.txt b.txt ab.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>*.txt</code>代表后缀名为<code>.txt</code>的所有文件。</p>
<p>如果想输出当前目录的所有文件，直接用<code>*</code>即可。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>*</code>可以匹配空字符，下面是一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span class="token function">ls</span> a*.txt
a.txt ab.txt

$ <span class="token function">ls</span> *b*
b.txt ab.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，<code>*</code>不会匹配隐藏文件（以<code>.</code>开头的文件），即<code>ls *</code>不会输出隐藏文件。</p>
<p>如果要匹配隐藏文件，需要写成<code>.*</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 显示所有隐藏文件</span>
$ <span class="token builtin class-name">echo</span> .*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果要匹配隐藏文件，同时要排除<code>.</code>和<code>..</code>这两个特殊的隐藏文件，可以与方括号扩展结合使用，写成<code>.[!.]*</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> .<span class="token punctuation">[</span><span class="token operator">!</span>.<span class="token punctuation">]</span>*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注意，<code>*</code>字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 当前目录不存在 c 开头的文件</span>
$ <span class="token builtin class-name">echo</span> c*.txt
c*.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，当前目录里面没有<code>c</code>开头的文件，导致<code>c*.txt</code>会原样输出。</p>
<p><code>*</code>只匹配当前目录，不会匹配子目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 子目录有一个 a.txt</span>
<span class="token comment"># 无效的写法</span>
$ <span class="token function">ls</span> *.txt

<span class="token comment"># 有效的写法</span>
$ <span class="token function">ls</span> */*.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子，文本文件在子目录，<code>*.txt</code>不会产生匹配，必须写成<code>*/*.txt</code>。有几层子目录，就必须写几层星号。</p>
<p>Bash 4.0 引入了一个参数<code>globstar</code>，当该参数打开时，允许<code>**</code>匹配零个或多个子目录。因此，<code>**/*.txt</code>可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面<code>shopt</code>命令的介绍。</p>
<h2 id="方括号扩展"><a href="#方括号扩展" class="headerlink" title="方括号扩展"></a>方括号扩展</h2><p>方括号扩展的形式是<code>[...]</code>，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，<code>[aeiou]</code>可以匹配五个元音字母中的任意一个。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 存在文件 a.txt 和 b.txt</span>
$ <span class="token function">ls</span> <span class="token punctuation">[</span>ab<span class="token punctuation">]</span>.txt
a.txt b.txt

<span class="token comment"># 只存在文件 a.txt</span>
$ <span class="token function">ls</span> <span class="token punctuation">[</span>ab<span class="token punctuation">]</span>.txt
a.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>[ab]</code>可以匹配<code>a</code>或<code>b</code>，前提是确实存在相应的文件。</p>
<p>方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 不存在文件 a.txt 和 b.txt</span>
$ <span class="token function">ls</span> <span class="token punctuation">[</span>ab<span class="token punctuation">]</span>.txt
ls: 无法访问<span class="token string">'[ab].txt'</span><span class="token builtin class-name">:</span> 没有那个文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，由于扩展后的文件不存在，<code>[ab].txt</code>就原样输出了，导致<code>ls</code>命名报错。</p>
<p>方括号扩展还有两种变体：<code>[^...]</code>和<code>[!...]</code>。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，<code>[^abc]</code>或<code>[!abc]</code>表示匹配除了<code>a</code>、<code>b</code>、<code>c</code>以外的字符。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 存在 aaa、bbb、aba 三个文件</span>
$ <span class="token function">ls</span> ?<span class="token punctuation">[</span><span class="token operator">!</span>a<span class="token punctuation">]</span>?
aba bbb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面命令中，<code>[!a]</code>表示文件名第二个字符不是<code>a</code>的文件名，所以返回了<code>aba</code>和<code>bbb</code>两个文件。</p>
<p>注意，如果需要匹配<code>[</code>字符，可以放在方括号内，比如<code>[[aeiou]</code>。如果需要匹配连字号<code>-</code>，只能放在方括号内部的开头或结尾，比如<code>[-aeiou]</code>或<code>[aeiou-]</code>。</p>
<h2 id="start-end-扩展"><a href="#start-end-扩展" class="headerlink" title="[start-end] 扩展"></a>[start-end] 扩展</h2><p>方括号扩展有一个简写形式<code>[start-end]</code>，表示匹配一个连续的范围。比如，<code>[a-c]</code>等同于<code>[abc]</code>，<code>[0-9]</code>匹配<code>[0123456789]</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 存在文件 a.txt、b.txt 和 c.txt</span>
$ <span class="token function">ls</span> <span class="token punctuation">[</span>a-c<span class="token punctuation">]</span>.txt
a.txt
b.txt
c.txt

<span class="token comment"># 存在文件 report1.txt、report2.txt 和 report3.txt</span>
$ <span class="token function">ls</span> report<span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>.txt
report1.txt
report2.txt
report3.txt
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面是一些常用简写的例子。</p>
<ul>
<li><code>[a-z]</code>：所有小写字母。</li>
<li><code>[a-zA-Z]</code>：所有小写字母与大写字母。</li>
<li><code>[a-zA-Z0-9]</code>：所有小写字母、大写字母与数字。</li>
<li><code>[abc]*</code>：所有以<code>a</code>、<code>b</code>、<code>c</code>字符之一开头的文件名。</li>
<li><code>program.[co]</code>：文件<code>program.c</code>与文件<code>program.o</code>。</li>
<li><code>BACKUP.[0-9][0-9][0-9]</code>：所有以<code>BACKUP.</code>开头，后面是三个数字的文件名。</li>
</ul>
<p>这种简写形式有一个否定形式<code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如，<code>[!a-zA-Z]</code>表示匹配非英文字母的字符。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> report<span class="token punctuation">[</span><span class="token operator">!</span><span class="token number">1</span>–3<span class="token punctuation">]</span>.txt
report4.txt report5.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面代码中，<code>[!1-3]</code>表示排除1、2和3。</p>
<h2 id="大括号扩展"><a href="#大括号扩展" class="headerlink" title="大括号扩展"></a>大括号扩展</h2><p>大括号扩展<code>&#123;...&#125;</code>表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，<code>&#123;1,2,3&#125;</code>扩展成<code>1 2 3</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span><span class="token number">1,2</span>,3<span class="token punctuation">&#125;</span>
<span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span>

$ <span class="token builtin class-name">echo</span> d<span class="token punctuation">&#123;</span>a,e,i,u,o<span class="token punctuation">&#125;</span>g
dag deg <span class="token function">dig</span> dug dog

$ <span class="token builtin class-name">echo</span> Front-<span class="token punctuation">&#123;</span>A,B,C<span class="token punctuation">&#125;</span>-Back
Front-A-Back Front-B-Back Front-C-Back<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> <span class="token punctuation">&#123;</span>a,b,c<span class="token punctuation">&#125;</span>.txt
ls: 无法访问<span class="token string">'a.txt'</span><span class="token builtin class-name">:</span> 没有那个文件或目录
ls: 无法访问<span class="token string">'b.txt'</span><span class="token builtin class-name">:</span> 没有那个文件或目录
ls: 无法访问<span class="token string">'c.txt'</span><span class="token builtin class-name">:</span> 没有那个文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，即使不存在对应的文件，<code>&#123;a,b,c&#125;</code>依然扩展成三个文件名，导致<code>ls</code>命令报了三个错误。</p>
<p>另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span><span class="token number">1</span> , <span class="token number">2</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#123;</span><span class="token number">1</span> , <span class="token number">2</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。</p>
<p>逗号前面可以没有值，表示扩展的第一项为空。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cp</span> a.log<span class="token punctuation">&#123;</span>,.bak<span class="token punctuation">&#125;</span>

<span class="token comment"># 等同于</span>
<span class="token comment"># cp a.log a.log.bak</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>大括号可以嵌套。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span>j<span class="token punctuation">&#123;</span>p,pe<span class="token punctuation">&#125;</span>g,png<span class="token punctuation">&#125;</span>
jpg jpeg png

$ <span class="token builtin class-name">echo</span> a<span class="token punctuation">&#123;</span>A<span class="token punctuation">&#123;</span><span class="token number">1,2</span><span class="token punctuation">&#125;</span>,B<span class="token punctuation">&#123;</span><span class="token number">3,4</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>b
aA1b aA2b aB3b aB4b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> /bin/<span class="token punctuation">&#123;</span>cat,b*<span class="token punctuation">&#125;</span>
/bin/cat /bin/b2sum /bin/base32 /bin/base64 <span class="token punctuation">..</span>. <span class="token punctuation">..</span>.

<span class="token comment"># 基本等同于</span>
$ <span class="token builtin class-name">echo</span> /bin/cat<span class="token punctuation">;</span><span class="token builtin class-name">echo</span> /bin/b*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，会先进行大括号扩展，然后进行<code>*</code>扩展，等同于执行两条<code>echo</code>命令。</p>
<p>大括号可以用于多字符的模式，方括号不行（只能匹配单字符）。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span>cat,dog<span class="token punctuation">&#125;</span>
<span class="token function">cat</span> dog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>由于大括号扩展<code>&#123;...&#125;</code>不是文件名扩展，所以它总是会扩展的。这与方括号扩展<code>[...]</code>完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 不存在 a.txt 和 b.txt</span>
$ <span class="token builtin class-name">echo</span> <span class="token punctuation">[</span>ab<span class="token punctuation">]</span>.txt
<span class="token punctuation">[</span>ab<span class="token punctuation">]</span>.txt

$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span>a,b<span class="token punctuation">&#125;</span>.txt
a.txt b.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，如果不存在<code>a.txt</code>和<code>b.txt</code>，那么<code>[ab].txt</code>就会变成一个普通的文件名，而<code>&#123;a,b&#125;.txt</code>可以照样扩展。</p>
<h2 id="start-end-扩展-1"><a href="#start-end-扩展-1" class="headerlink" title="{start..end} 扩展"></a>{start..end} 扩展</h2><p>大括号扩展有一个简写形式<code>&#123;start..end&#125;</code>，表示扩展成一个连续序列。比如，<code>&#123;a..z&#125;</code>可以扩展成26个小写英文字母。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span>a<span class="token punctuation">..</span>c<span class="token punctuation">&#125;</span>
a b c

$ <span class="token builtin class-name">echo</span> d<span class="token punctuation">&#123;</span>a<span class="token punctuation">..</span>d<span class="token punctuation">&#125;</span>g
dag dbg dcg ddg

$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">4</span><span class="token punctuation">&#125;</span>
<span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span>

$ <span class="token builtin class-name">echo</span> Number_<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">&#125;</span>
Number_1 Number_2 Number_3 Number_4 Number_5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这种简写形式支持逆序。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span>c<span class="token punctuation">..</span>a<span class="token punctuation">&#125;</span>
c b a

$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">..</span><span class="token number">1</span><span class="token punctuation">&#125;</span>
<span class="token number">5</span> <span class="token number">4</span> <span class="token number">3</span> <span class="token number">2</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span>a1<span class="token punctuation">..</span>3c<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#123;</span>a1<span class="token punctuation">..</span>3c<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这种简写形式可以嵌套使用，形成复杂的扩展。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> .<span class="token punctuation">&#123;</span>mp<span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">..</span><span class="token number">4</span><span class="token punctuation">&#125;</span>,m4<span class="token punctuation">&#123;</span>a,b,p,v<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
.mp3 .mp4 .m4a .m4b .m4p .m4v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>大括号扩展的常见用途为新建一系列目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> <span class="token punctuation">&#123;</span><span class="token number">2007</span><span class="token punctuation">..</span><span class="token number">2009</span><span class="token punctuation">&#125;</span>-<span class="token punctuation">&#123;</span>01<span class="token punctuation">..</span><span class="token number">12</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令会新建36个子目录，每个子目录的名字都是”年份-月份“。</p>
<p>这个写法的另一个常见用途，是直接用于<code>for</code>循环。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">4</span><span class="token punctuation">&#125;</span>
<span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token variable">$i</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子会循环4次。</p>
<p>如果整数前面有前导<code>0</code>，扩展输出的每一项都有前导<code>0</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span>01<span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">&#125;</span>
01 02 03 04 05

$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span>001<span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">&#125;</span>
001 002 003 004 005<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这种简写形式还可以使用第二个双点号（<code>start..end..step</code>），用来指定扩展的步长。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">8</span><span class="token punctuation">..</span><span class="token number">2</span><span class="token punctuation">&#125;</span>
<span class="token number">0</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面代码将<code>0</code>扩展到<code>8</code>，每次递增的长度为<code>2</code>，所以一共输出5个数字。</p>
<p>多个简写形式连用，会有循环处理的效果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">&#123;</span>a<span class="token punctuation">..</span>c<span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">3</span><span class="token punctuation">&#125;</span>
a1 a2 a3 b1 b2 b3 c1 c2 c3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="变量扩展"><a href="#变量扩展" class="headerlink" title="变量扩展"></a>变量扩展</h2><p>Bash 将美元符号<code>$</code>开头的词元视为变量，将其扩展成变量值，详见《Bash 变量》一章。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$SHELL</span>
/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>变量名除了放在美元符号后面，也可以放在<code>$&#123;&#125;</code>里面。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token environment constant">SHELL</span>&#125;</span>
/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>$&#123;!string*&#125;</code>或<code>$&#123;!string@&#125;</code>返回所有匹配给定字符串<code>string</code>的变量名。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token operator">!</span>S*&#125;</span>
<span class="token environment constant">SECONDS</span> <span class="token environment constant">SHELL</span> <span class="token environment constant">SHELLOPTS</span> <span class="token environment constant">SHLVL</span> SSH_AGENT_PID <span class="token environment constant">SSH_AUTH_SOCK</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，<code>$&#123;!S*&#125;</code>扩展成所有以<code>S</code>开头的变量名。</p>
<h2 id="子命令扩展"><a href="#子命令扩展" class="headerlink" title="子命令扩展"></a>子命令扩展</h2><p><code>$(...)</code>可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span>
Tue Jan <span class="token number">28</span> 00:01:13 CST <span class="token number">2020</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，<code>$(date)</code>返回<code>date</code>命令的运行结果。</p>
<p>还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">date</span><span class="token variable">`</span></span>
Tue Jan <span class="token number">28</span> 00:01:13 CST <span class="token number">2020</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>$(...)</code>可以嵌套，比如<code>$(ls $(pwd))</code>。</p>
<h2 id="算术扩展"><a href="#算术扩展" class="headerlink" title="算术扩展"></a>算术扩展</h2><p><code>$((...))</code>可以扩展成整数运算的结果，详见《Bash 的算术运算》一章。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token variable">))</span></span>
<span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p><code>[[:class:]]</code>表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。</p>
<ul>
<li><code>[[:alnum:]]</code>：匹配任意英文字母与数字</li>
<li><code>[[:alpha:]]</code>：匹配任意英文字母</li>
<li><code>[[:blank:]]</code>：空格和 Tab 键。</li>
<li><code>[[:cntrl:]]</code>：ASCII 码 0-31 的不可打印字符。</li>
<li><code>[[:digit:]]</code>：匹配任意数字 0-9。</li>
<li><code>[[:graph:]]</code>：A-Z、a-z、0-9 和标点符号。</li>
<li><code>[[:lower:]]</code>：匹配任意小写字母 a-z。</li>
<li><code>[[:print:]]</code>：ASCII 码 32-127 的可打印字符。</li>
<li><code>[[:punct:]]</code>：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。</li>
<li><code>[[:space:]]</code>：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。</li>
<li><code>[[:upper:]]</code>：匹配任意大写字母 A-Z。</li>
<li><code>[[:xdigit:]]</code>：16进制字符（A-F、a-f、0-9）。</li>
</ul>
<p>请看下面的例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>:upper:<span class="token punctuation">]</span><span class="token punctuation">]</span>*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令输出所有大写字母开头的文件名。</p>
<p>字符类的第一个方括号后面，可以加上感叹号<code>!</code>，表示否定。比如，<code>[![:digit:]]</code>匹配所有非数字。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">[</span><span class="token operator">!</span><span class="token punctuation">[</span>:digit:<span class="token punctuation">]</span><span class="token punctuation">]</span>*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令输出所有不以数字开头的文件名。</p>
<p>字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 不存在以大写字母开头的文件</span>
$ <span class="token builtin class-name">echo</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>:upper:<span class="token punctuation">]</span><span class="token punctuation">]</span>*
<span class="token punctuation">[</span><span class="token punctuation">[</span>:upper:<span class="token punctuation">]</span><span class="token punctuation">]</span>*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，由于没有可匹配的文件，字符类就原样输出了。</p>
<h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><p>通配符有一些使用注意点，不可不知。</p>
<p><strong>（1）通配符是先解释，再执行。</strong></p>
<p>Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> a*.txt
ab.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面命令的执行过程是，Bash 先将<code>a*.txt</code>扩展成<code>ab.txt</code>，然后再执行<code>ls ab.txt</code>。</p>
<p><strong>（2）文件名扩展在不匹配时，会原样输出。</strong></p>
<p>文件名扩展在没有可匹配的文件时，会原样输出。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 不存在 r 开头的文件名</span>
$ <span class="token builtin class-name">echo</span> r*
r*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，由于不存在<code>r</code>开头的文件名，<code>r*</code>会原样输出。</p>
<p>下面是另一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> *.csv
ls: *.csv: No such <span class="token function">file</span> or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>另外，前面已经说过，大括号扩展<code>&#123;...&#125;</code>不是文件名扩展。</p>
<p><strong>（3）只适用于单层路径。</strong></p>
<p>所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code>或<code>*</code>这样的通配符，不能匹配路径分隔符（<code>/</code>）。</p>
<p>如果要匹配子目录里面的文件，可以写成下面这样。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> */*.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Bash 4.0 新增了一个<code>globstar</code>参数，允许<code>**</code>匹配零个或多个子目录，详见后面<code>shopt</code>命令的介绍。</p>
<p><strong>（4）文件名可以使用通配符。</strong></p>
<p>Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号或双引号里面。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">touch</span> <span class="token string">'fo*'</span>
$ <span class="token function">ls</span>
fo*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面代码创建了一个<code>fo*</code>文件，这时<code>*</code>就是文件名的一部分。</p>
<h2 id="量词语法"><a href="#量词语法" class="headerlink" title="量词语法"></a>量词语法</h2><p>量词语法用来控制模式匹配的次数。它只有在 Bash 的<code>extglob</code>参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> extglob
extglob        	on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果<code>extglob</code>参数是关闭的，可以用下面的命令打开。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> -s extglob<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>量词语法有下面几个。</p>
<ul>
<li><code>?(pattern-list)</code>：匹配零个或一个模式。</li>
<li><code>*(pattern-list)</code>：匹配零个或多个模式。</li>
<li><code>+(pattern-list)</code>：匹配一个或多个模式。</li>
<li><code>@(pattern-list)</code>：只匹配一个模式。</li>
<li><code>!(pattern-list)</code>：匹配给定模式以外的任何内容。</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> abc?<span class="token punctuation">(</span>.<span class="token punctuation">)</span>txt
abctxt abc.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，<code>?(.)</code>匹配零个或一个点。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> abc?<span class="token punctuation">(</span>def<span class="token punctuation">)</span>
abc abcdef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，<code>?(def)</code>匹配零个或一个<code>def</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> abc+<span class="token punctuation">(</span>.txt<span class="token operator">|</span>.php<span class="token punctuation">)</span>
abc.php abc.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，<code>+(.txt|.php)</code>匹配文件有一个<code>.txt</code>或<code>.php</code>后缀名。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> abc+<span class="token punctuation">(</span>.txt<span class="token punctuation">)</span>
abc.txt abc.txt.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，<code>+(.txt)</code>匹配文件有一个或多个<code>.txt</code>后缀名。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> a<span class="token operator">!</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>.txt
a.txt abb.txt ac.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，<code>!(b)</code>表示匹配单个字母<code>b</code>以外的任意内容，所以除了<code>ab.txt</code>以外，其他文件名都能匹配。</p>
<p>量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 没有 abc 开头的文件名</span>
$ <span class="token function">ls</span> abc?<span class="token punctuation">(</span>def<span class="token punctuation">)</span>
ls: 无法访问<span class="token string">'abc?(def)'</span><span class="token builtin class-name">:</span> 没有那个文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，由于没有可匹配的文件，<code>abc?(def)</code>就原样输出，导致<code>ls</code>命令报错。</p>
<h2 id="shopt-命令"><a href="#shopt-命令" class="headerlink" title="shopt 命令"></a>shopt 命令</h2><p><code>shopt</code>命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。</p>
<p><code>shopt</code>命令的使用方法如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 打开某个参数</span>
$ <span class="token builtin class-name">shopt</span> -s <span class="token punctuation">[</span>optionname<span class="token punctuation">]</span>

<span class="token comment"># 关闭某个参数</span>
$ <span class="token builtin class-name">shopt</span> -u <span class="token punctuation">[</span>optionname<span class="token punctuation">]</span>

<span class="token comment"># 查询某个参数关闭还是打开</span>
$ <span class="token builtin class-name">shopt</span> <span class="token punctuation">[</span>optionname<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>（1）dotglob 参数</strong></p>
<p><code>dotglob</code>参数可以让扩展结果包括隐藏文件（即点开头的文件）。</p>
<p>正常情况下，扩展结果不包括隐藏文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> *
abc.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>打开<code>dotglob</code>，就会包括隐藏文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> -s dotglob
$ <span class="token function">ls</span> *
abc.txt .config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>（2）nullglob 参数</strong></p>
<p><code>nullglob</code>参数可以让通配符不匹配任何文件名时，返回空字符。</p>
<p>默认情况下，通配符不匹配任何文件名时，会保持不变。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> b*
rm: 无法删除<span class="token string">'b*'</span><span class="token builtin class-name">:</span> 没有那个文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，由于当前目录不包括<code>b</code>开头的文件名，导致<code>b*</code>不会发生文件名扩展，保持原样不变，所以<code>rm</code>命令报错没有<code>b*</code>这个文件。</p>
<p>打开<code>nullglob</code>参数，就可以让不匹配的通配符返回空字符串。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> -s nullglob
$ <span class="token function">rm</span> b*
rm: 缺少操作数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，由于没有<code>b*</code>匹配的文件名，所以<code>rm b*</code>扩展成了<code>rm</code>，导致报错变成了”缺少操作数“。</p>
<p><strong>（3）failglob 参数</strong></p>
<p><code>failglob</code>参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> -s failglob
$ <span class="token function">rm</span> b*
bash: 无匹配: b*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，打开<code>failglob</code>以后，由于<code>b*</code>不匹配任何文件名，Bash 直接报错了，不再让<code>rm</code>命令去处理。</p>
<p><strong>（4）extglob 参数</strong></p>
<p><code>extglob</code>参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> extglob
extglob        	on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> -u extglob<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>（5）nocaseglob 参数</strong></p>
<p><code>nocaseglob</code>参数可以让通配符扩展不区分大小写。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> -s nocaseglob
$ <span class="token function">ls</span> /windows/program*
/windows/ProgramData
/windows/Program Files
/windows/Program Files <span class="token punctuation">(</span>x86<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，打开<code>nocaseglob</code>以后，<code>program*</code>就不区分大小写了，可以匹配<code>ProgramData</code>等。</p>
<p><strong>（6）globstar 参数</strong></p>
<p><code>globstar</code>参数可以使得<code>**</code>匹配零个或多个子目录。该参数默认是关闭的。</p>
<p>假设有下面的文件结构。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a.txt
sub1/b.txt
sub1/sub2/c.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面的文件结构中，顶层目录、第一级子目录<code>sub1</code>、第二级子目录<code>sub1\sub2</code>里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来？</p>
<p>默认情况下，只能写成下面这样。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> *.txt */*.txt */*/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这是因为<code>*</code>只匹配当前目录，如果要匹配子目录，只能一层层写出来。</p>
<p>打开<code>globstar</code>参数以后，<code>**</code>匹配零个或多个子目录。因此，<code>**/*.txt</code>就可以得到想要的结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> -s globstar
$ <span class="token function">ls</span> **/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://medium.com/@leedowthwaite/why-most-people-only-think-they-understand-wildcards-63bb9c2024ab">Think You Understand Wildcards? Think Again</a></li>
<li><a target="_blank" rel="noopener" href="https://appcodelabs.com/advanced-wildcard-patterns-most-people-dont-know">Advanced Wildcard Patterns Most People Don’t Know</a></li>
</ul>
<h1 id="引号和转义"><a href="#引号和转义" class="headerlink" title="引号和转义"></a>引号和转义</h1><p>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。</p>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>某些字符在 Bash 里面有特殊含义（比如<code>$</code>、<code>&amp;</code>、<code>*</code>）。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable">$date</span>

$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，输出<code>$date</code>不会有任何结果，因为<code>$</code>是一个特殊字符。</p>
<p>如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做“转义”（escape）。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">\</span><span class="token variable">$date</span>
<span class="token variable">$date</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面命令中，只有在特殊字符<code>$</code>前面加反斜杠，才能原样输出。</p>
<p>反斜杠本身也是特殊字符，如果想要原样输出反斜杠，就需要对它自身转义，连续使用两个反斜线（<code>\\</code>）。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token punctuation">\</span><span class="token punctuation">\</span>
<span class="token punctuation">\</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子输出了反斜杠本身。</p>
<p>反斜杠除了用于转义，还可以表示一些不可打印的字符。</p>
<ul>
<li><code>\a</code>：响铃</li>
<li><code>\b</code>：退格</li>
<li><code>\n</code>：换行</li>
<li><code>\r</code>：回车</li>
<li><code>\t</code>：制表符</li>
</ul>
<p>如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用<code>echo</code>命令的<code>-e</code>参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> a<span class="token punctuation">\</span>tb
atb

$ <span class="token builtin class-name">echo</span> -e <span class="token string">"a<span class="token entity" title="\t">\t</span>b"</span>
a        b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，命令行直接输出不可打印字符<code>\t</code>，Bash 不能正确解释。必须把它们放在引号之中，然后使用<code>echo</code>命令的<code>-e</code>参数。</p>
<p>换行符是一个特殊字符，表示命令的结束，Bash 收到这个字符以后，就会对输入的命令进行解释执行。换行符前面加上反斜杠转义，就使得换行符变成一个普通字符，Bash 会将其当作空格处理，从而可以将一行命令写成多行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mv</span> <span class="token punctuation">\</span>
/path/to/foo <span class="token punctuation">\</span>
/path/to/bar

<span class="token comment"># 等同于</span>
$ <span class="token function">mv</span> /path/to/foo /path/to/bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，如果一条命令过长，就可以在行尾使用反斜杠，将其改写成多行。这是常见的多行命令的写法。</p>
<h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><p>Bash 允许字符串放在单引号或双引号之中，加以引用。</p>
<p>单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号（<code>*</code>）、美元符号（<code>$</code>）、反斜杠（<code>\</code>）等。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">'*'</span>
*

$ <span class="token builtin class-name">echo</span> <span class="token string">'<span class="token environment constant">$USER</span>'</span>
<span class="token environment constant">$USER</span>

$ <span class="token builtin class-name">echo</span> <span class="token string">'<span class="token variable"><span class="token variable">$((</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token variable">))</span></span>'</span>
<span class="token variable"><span class="token variable">$((</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token variable">))</span></span>

$ <span class="token builtin class-name">echo</span> <span class="token string">'<span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> foo<span class="token variable">)</span></span>'</span>
<span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> foo<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面命令中，单引号使得 Bash 扩展、变量引用、算术运算和子命令，都失效了。如果不使用单引号，它们都会被 Bash 自动扩展。</p>
<p>由于反斜杠在单引号里面变成了普通字符，所以如果单引号之中，还要使用单引号，不能使用转义，需要在外层的单引号前面加上一个美元符号（<code>$</code>），然后再对里层的单引号转义。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 不正确</span>
$ <span class="token builtin class-name">echo</span> it<span class="token string">'s

# 不正确
$ echo '</span>it<span class="token punctuation">\</span>'s<span class="token string">'

# 正确
$ echo $'</span>it<span class="token punctuation">\</span>'s'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不过，更合理的方法是改在双引号之中使用单引号。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"it's"</span>
it's<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><p>双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通字符。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"*"</span>
*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，通配符<code>*</code>是一个特殊字符，放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，这意味着，双引号里面不会进行文件名扩展。</p>
<p>但是，三个特殊字符除外：美元符号（<code>$</code>）、反引号（<code>`</code>）和反斜杠（<code>\</code>）。这三个字符在双引号之中，依然有特殊含义，会被 Bash 自动扩展。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token environment constant">$SHELL</span>"</span>
/bin/bash

$ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable"><span class="token variable">`</span><span class="token function">date</span><span class="token variable">`</span></span>"</span>
Mon Jan <span class="token number">27</span> <span class="token number">13</span>:33:18 CST <span class="token number">2020</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，美元符号（<code>$</code>）和反引号（<code>`</code>）在双引号中，都保持特殊含义。美元符号用来引用变量，反引号则是执行子命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"I'd say: <span class="token entity" title="\&quot;">\"</span>hello!<span class="token entity" title="\&quot;">\"</span>"</span>
I'd say: <span class="token string">"hello!"</span>

$ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token entity" title="\\">\\</span>"</span>
<span class="token punctuation">\</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，反斜杠在双引号之中保持特殊含义，用来转义。所以，可以使用反斜杠，在双引号之中插入双引号，或者插入反斜杠本身。</p>
<p>换行符在双引号之中，会失去特殊含义，Bash 不再将其解释为命令的结束，只是作为普通的换行符。所以可以利用双引号，在命令行输入多行文本。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"hello
world"</span>
hello
world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面命令中，Bash 正常情况下会将换行符解释为命令结束，但是换行符在双引号之中就失去了这种特殊作用，只用来换行，所以可以输入多行。<code>echo</code>命令会将换行符原样输出，显示的时候正常解释为换行。</p>
<p>双引号的另一个常见的使用场合是，文件名包含空格。这时就必须使用双引号（或单引号），将文件名放在里面。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> <span class="token string">"two words.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令中，<code>two words.txt</code>是一个包含空格的文件名，否则就会被 Bash 当作两个文件。</p>
<p>双引号会原样保存多余的空格。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"this is a     test"</span>
this is a     <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>双引号还有一个作用，就是保存原始命令的输出格式。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 单行输出</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">cal</span><span class="token variable">)</span></span>
一月 <span class="token number">2020</span> 日 一 二 三 四 五 六 <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token punctuation">..</span>. <span class="token number">31</span>

<span class="token comment"># 原始格式输出</span>
$ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">cal</span><span class="token variable">)</span></span>"</span>
      一月 <span class="token number">2020</span>
日 一 二 三 四 五 六
          <span class="token number">1</span>  <span class="token number">2</span>  <span class="token number">3</span>  <span class="token number">4</span>
 <span class="token number">5</span>  <span class="token number">6</span>  <span class="token number">7</span>  <span class="token number">8</span>  <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span>
<span class="token number">12</span> <span class="token number">13</span> <span class="token number">14</span> <span class="token number">15</span> <span class="token number">16</span> <span class="token number">17</span> <span class="token number">18</span>
<span class="token number">19</span> <span class="token number">20</span> <span class="token number">21</span> <span class="token number">22</span> <span class="token number">23</span> <span class="token number">24</span> <span class="token number">25</span>
<span class="token number">26</span> <span class="token number">27</span> <span class="token number">28</span> <span class="token number">29</span> <span class="token number">30</span> <span class="token number">31</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，如果<code>$(cal)</code>不放在双引号之中，<code>echo</code>就会将所有结果以单行输出，丢弃了所有原始的格式。</p>
<h2 id="Here-文档"><a href="#Here-文档" class="headerlink" title="Here 文档"></a>Here 文档</h2><p>Here 文档（here document）是一种输入多行字符串的方法，格式如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&lt;&lt;</span> <span class="token string">token
text
token</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>它的格式分成开始标记（<code>&lt;&lt; token</code>）和结束标记（<code>token</code>）。开始标记是两个小于号 + Here 文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。</p>
<p>下面是一个通过 Here 文档输出 HTML 代码的例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">_EOF_
&lt;html>
&lt;head>
    &lt;title>
    The title of your page
    &lt;/title>
&lt;/head>

&lt;body>
    Your page content goes here.
&lt;/body>
&lt;/html>
_EOF_</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token string">'hello world'</span>
$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">_example_
<span class="token variable">$foo</span>
"<span class="token variable">$foo</span>"
'<span class="token variable">$foo</span>'
_example_</span>

hello world
<span class="token string">"hello world"</span>
<span class="token string">'hello world'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，变量<code>$foo</code>发生了替换，但是双引号和单引号都原样输出了，表明它们已经失去了引用的功能。</p>
<p>如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token string">'hello world'</span>
$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'_example_'
$foo
"$foo"
'$foo'
_example_</span>

<span class="token variable">$foo</span>
<span class="token string">"<span class="token variable">$foo</span>"</span>
<span class="token string">'<span class="token variable">$foo</span>'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，Here 文档的开始标记（<code>_example_</code>）放在单引号之中，导致变量替换失效了。</p>
<p>Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了<code>echo</code>命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">command</span> <span class="token operator">&lt;&lt;</span> <span class="token string">token
  string
token</span>

<span class="token comment"># 等同于</span>

$ <span class="token builtin class-name">echo</span> string <span class="token operator">|</span> <span class="token builtin class-name">command</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，Here 文档相当于<code>echo</code>命令的重定向。</p>
<p>所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如<code>echo</code>命令就不能用 Here 文档作为参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token operator">&lt;&lt;</span> <span class="token string">_example_
hello
_example_</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子不会有任何输出，因为 Here 文档对于<code>echo</code>命令无效。</p>
<p>此外，Here 文档也不能作为变量的值，只能用于命令的参数。</p>
<h2 id="Here-字符串"><a href="#Here-字符串" class="headerlink" title="Here 字符串"></a>Here 字符串</h2><p>Here 文档还有一个变体，叫做 Here 字符串（Here string），使用三个小于号（<code>&lt;&lt;&lt;</code>）表示。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&lt;&lt;&lt;</span> string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>它的作用是将字符串通过标准输入，传递给命令。</p>
<p>有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如<code>cat</code>命令只接受标准输入传入的字符串。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">'hi there'</span>
<span class="token comment"># 等同于</span>
$ <span class="token builtin class-name">echo</span> <span class="token string">'hi there'</span> <span class="token operator">|</span> <span class="token function">cat</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面的第一种语法使用了 Here 字符串，要比第二种语法看上去语义更好，也更简洁。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ md5sum <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">'ddd'</span>
<span class="token comment"># 等同于</span>
$ <span class="token builtin class-name">echo</span> <span class="token string">'ddd'</span> <span class="token operator">|</span> md5sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>md5sum</code>命令只能接受标准输入作为参数，不能直接将字符串放在命令后面，会被当作文件名，即<code>md5sum ddd</code>里面的<code>ddd</code>会被解释成文件名。这时就可以用 Here 字符串，将字符串传给<code>md5sum</code>命令。</p>
<h1 id="Bash-变量"><a href="#Bash-变量" class="headerlink" title="Bash 变量"></a>Bash 变量</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>Bash 变量分成环境变量和自定义变量两类。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。</p>
<p><code>env</code>命令或<code>printenv</code>命令，可以显示所有环境变量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">env</span>
<span class="token comment"># 或者</span>
$ <span class="token function">printenv</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>下面是一些常见的环境变量。</p>
<ul>
<li><code>BASHPID</code>：Bash 进程的进程 ID。</li>
<li><code>BASHOPTS</code>：当前 Shell 的参数，可以用<code>shopt</code>命令修改。</li>
<li><code>DISPLAY</code>：图形环境的显示器名字，通常是<code>:0</code>，表示 X Server 的第一个显示器。</li>
<li><code>EDITOR</code>：默认的文本编辑器。</li>
<li><code>HOME</code>：用户的主目录。</li>
<li><code>HOST</code>：当前主机的名称。</li>
<li><code>IFS</code>：词与词之间的分隔符，默认为空格。</li>
<li><code>LANG</code>：字符集以及语言编码，比如<code>zh_CN.UTF-8</code>。</li>
<li><code>PATH</code>：由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。</li>
<li><code>PS1</code>：Shell 提示符。</li>
<li><code>PS2</code>： 输入多行命令时，次要的 Shell 提示符。</li>
<li><code>PWD</code>：当前工作目录。</li>
<li><code>RANDOM</code>：返回一个0到32767之间的随机数。</li>
<li><code>SHELL</code>：Shell 的名字。</li>
<li><code>SHELLOPTS</code>：启动当前 Shell 的<code>set</code>命令的参数，参见《set 命令》一章。</li>
<li><code>TERM</code>：终端类型名，即终端仿真器所用的协议。</li>
<li><code>UID</code>：当前用户的 ID 编号。</li>
<li><code>USER</code>：当前用户的用户名。</li>
</ul>
<p>很多环境变量很少发生变化，而且是只读的，可以视为常量。由于它们的变量名全部都是大写，所以传统上，如果用户要自己定义一个常量，也会使用全部大写的变量名。</p>
<p>注意，Bash 变量名区分大小写，<code>HOME</code>和<code>home</code>是两个不同的变量。</p>
<p>查看单个环境变量的值，可以使用<code>printenv</code>命令或<code>echo</code>命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">printenv</span> <span class="token environment constant">PATH</span>
<span class="token comment"># 或者</span>
$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>注意，<code>printenv</code>命令后面的变量名，不用加前缀<code>$</code>。</p>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>自定义变量是用户在当前 Shell 里面自己定义的变量，仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。</p>
<p><code>set</code>命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">set</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h2><p>用户创建变量的时候，变量名必须遵守下面的规则。</p>
<ul>
<li>字母、数字和下划线字符组成。</li>
<li>第一个字符必须是一个字母或一个下划线，不能是数字。</li>
<li>不允许出现空格和标点符号。</li>
</ul>
<p>变量声明的语法如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">variable</span><span class="token operator">=</span>value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令中，等号左边是变量名，右边是变量。注意，等号两边不能有空格。</p>
<p>如果变量的值包含空格，则必须将值放在引号中。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">myvar</span><span class="token operator">=</span><span class="token string">"hello world"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Bash 没有数据类型的概念，所有的变量值都是字符串。</p>
<p>下面是一些自定义变量的例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">a</span><span class="token operator">=</span>z                     <span class="token comment"># 变量 a 赋值为字符串 z</span>
<span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token string">"a string"</span>            <span class="token comment"># 变量值包含空格，就必须放在引号里面</span>
<span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token string">"a string and <span class="token variable">$b</span>"</span>     <span class="token comment"># 变量值可以引用其他变量的值</span>
<span class="token assign-left variable">d</span><span class="token operator">=</span><span class="token string">"<span class="token entity" title="\t">\t</span><span class="token entity" title="\t">\t</span>a string<span class="token entity" title="\n">\n</span>"</span>      <span class="token comment"># 变量值可以使用转义字符</span>
<span class="token assign-left variable">e</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span> -l foo.txt<span class="token variable">)</span></span>      <span class="token comment"># 变量值可以是命令的执行结果</span>
<span class="token assign-left variable">f</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token number">7</span><span class="token variable">))</span></span>            <span class="token comment"># 变量值可以是数学运算的结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>变量可以重复赋值，后面的赋值会覆盖前面的赋值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">1</span>
$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">2</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，变量<code>foo</code>的第二次赋值会覆盖第一次赋值。</p>
<p>如果同一行定义多个变量，必须使用分号（<code>;</code>）分隔。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token assign-left variable">bar</span><span class="token operator">=</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，同一行定义了<code>foo</code>和<code>bar</code>两个变量。</p>
<h2 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h2><p>读取变量的时候，直接在变量名前加上<code>$</code>就可以了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>bar
$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>每当 Shell 看到以<code>$</code>开头的单词时，就会尝试读取这个变量名对应的值。</p>
<p>如果变量不存在，Bash 不会报错，而会输出空字符。</p>
<p>由于<code>$</code>在 Bash 中有特殊含义，把它当作美元符号使用时，一定要非常小心，</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> The total is <span class="token variable">$100</span>.00
The total is 00.00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面命令的原意是输入<code>$100</code>，但是 Bash 将<code>$1</code>解释成了变量，该变量为空，因此输入就变成了<code>00.00</code>。所以，如果要使用<code>$</code>的原义，需要在<code>$</code>前面放上反斜杠，进行转义。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> The total is <span class="token punctuation">\</span><span class="token variable">$100</span>.00
The total is <span class="token variable">$100</span>.00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>读取变量的时候，变量名也可以使用花括号<code>&#123;&#125;</code>包围，比如<code>$a</code>也可以写成<code>$&#123;a&#125;</code>。这种写法可以用于变量名与其他字符连用的情况。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">a</span><span class="token operator">=</span>foo
$ <span class="token builtin class-name">echo</span> <span class="token variable">$a_file</span>

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;a&#125;</span>_file
foo_file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，变量名<code>a_file</code>不会有任何输出，因为 Bash 将其整个解释为变量，而这个变量是不存在的。只有用花括号区分<code>$a</code>，Bash 才能正确解读。</p>
<p>事实上，读取变量的语法<code>$foo</code>，可以看作是<code>$&#123;foo&#125;</code>的简写形式。</p>
<p>如果变量的值本身也是变量，可以使用<code>$&#123;!varname&#125;</code>的语法，读取最终的值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">myvar</span><span class="token operator">=</span><span class="token environment constant">USER</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token operator">!</span>myvar&#125;</span>
ruanyf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面的例子中，变量<code>myvar</code>的值是<code>USER</code>，<code>$&#123;!myvar&#125;</code>的写法将其展开成最终的值。</p>
<p>如果变量值包含连续空格（或制表符和换行符），最好放在双引号里面读取。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token string">"1 2  3"</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$a</span>
<span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span>
$ <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$a</span>"</span>
<span class="token number">1</span> <span class="token number">2</span>  <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面示例中，变量<code>a</code>的值包含两个连续空格。如果直接读取，Shell 会将连续空格合并成一个。只有放在双引号里面读取，才能保持原来的格式。</p>
<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p><code>unset</code>命令用来删除一个变量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">unset</span> NAME<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使<code>unset</code>命令删除了变量，还是可以读取这个变量，值为空字符串。</p>
<p>所以，删除一个变量，也可以将这个变量设成空字符串。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token string">''</span>
$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面两种写法，都是删除了变量<code>foo</code>。由于不存在的值默认为空字符串，所以后一种写法可以在等号右边不写任何值。</p>
<h2 id="输出变量，export-命令"><a href="#输出变量，export-命令" class="headerlink" title="输出变量，export 命令"></a>输出变量，export 命令</h2><p>用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用<code>export</code>命令。这样输出的变量，对于子 Shell 来说就是环境变量。</p>
<p><code>export</code>命令用来向子 Shell 输出变量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">NAME</span><span class="token operator">=</span>foo
<span class="token builtin class-name">export</span> NAME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面命令输出了变量<code>NAME</code>。变量的赋值和输出也可以在一个步骤中完成。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">NAME</span><span class="token operator">=</span>value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令执行后，当前 Shell 及随后新建的子 Shell，都可以读取变量<code>$NAME</code>。</p>
<p>子 Shell 如果修改继承的变量，不会影响父 Shell。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 输出变量 $foo</span>
$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">foo</span><span class="token operator">=</span>bar

<span class="token comment"># 新建子 Shell</span>
$ <span class="token function">bash</span>

<span class="token comment"># 读取 $foo</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
bar

<span class="token comment"># 修改继承的变量</span>
$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>baz

<span class="token comment"># 退出子 Shell</span>
$ <span class="token builtin class-name">exit</span>

<span class="token comment"># 读取 $foo</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，子 Shell 修改了继承的变量<code>$foo</code>，对父 Shell 没有影响。</p>
<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><p>Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。</p>
<p>（1）<code>$?</code></p>
<p><code>$?</code>为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是<code>0</code>，表示上一个命令执行成功；如果是非零，上一个命令执行失败。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> doesnotexist
ls: doesnotexist: No such <span class="token function">file</span> or directory

$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>ls</code>命令查看一个不存在的文件，导致报错。<code>$?</code>为1，表示上一个命令执行失败。</p>
<p>（2）<code>$$</code></p>
<p><code>$$</code>为当前 Shell 的进程 ID。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable">$$</span>
<span class="token number">10662</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这个特殊变量可以用来命名临时文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">LOGFILE</span><span class="token operator">=</span>/tmp/output_log.<span class="token variable">$$</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>（3）<code>$_</code></p>
<p><code>$_</code>为上一个命令的最后一个参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">grep</span> dictionary /usr/share/dict/words
dictionary

$ <span class="token builtin class-name">echo</span> <span class="token variable">$_</span>
/usr/share/dict/words<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（4）<code>$!</code></p>
<p><code>$!</code>为最近一个后台执行的异步命令的进程 ID。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ firefox <span class="token operator">&amp;</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">11064</span>

$ <span class="token builtin class-name">echo</span> <span class="token variable">$!</span>
<span class="token number">11064</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>firefox</code>是后台运行的命令，<code>$!</code>返回该命令的进程 ID。</p>
<p>（5）<code>$0</code></p>
<p><code>$0</code>为当前 Shell 的名称（在命令行直接执行时）或者脚本名（在脚本中执行时）。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable">$0</span>
<span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，<code>$0</code>返回当前运行的是 Bash。</p>
<p>（6）<code>$-</code></p>
<p><code>$-</code>为当前 Shell 的启动参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> $-
himBHs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>（7）<code>$@</code>和<code>$#</code></p>
<p><code>$#</code>表示脚本的参数数量，<code>$@</code>表示脚本的参数值，参见脚本一章。</p>
<h2 id="变量的默认值"><a href="#变量的默认值" class="headerlink" title="变量的默认值"></a>变量的默认值</h2><p>Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$&#123;varname<span class="token operator">:-</span>word&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面语法的含义是，如果变量<code>varname</code>存在且不为空，则返回它的值，否则返回<code>word</code>。它的目的是返回一个默认值，比如<code>$&#123;count:-0&#125;</code>表示变量<code>count</code>不存在时返回<code>0</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$&#123;varname<span class="token operator">:=</span>word&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面语法的含义是，如果变量<code>varname</code>存在且不为空，则返回它的值，否则将它设为<code>word</code>，并且返回<code>word</code>。它的目的是设置变量的默认值，比如<code>$&#123;count:=0&#125;</code>表示变量<code>count</code>不存在时返回<code>0</code>，且将<code>count</code>设为<code>0</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$&#123;varname<span class="token operator">:+</span>word&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面语法的含义是，如果变量名存在且不为空，则返回<code>word</code>，否则返回空值。它的目的是测试变量是否存在，比如<code>$&#123;count:+1&#125;</code>表示变量<code>count</code>存在时返回<code>1</code>（表示<code>true</code>），否则返回空值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$&#123;varname<span class="token operator">:?</span>message&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面语法的含义是，如果变量<code>varname</code>存在且不为空，则返回它的值，否则打印出<code>varname: message</code>，并中断脚本的执行。如果省略了<code>message</code>，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义，比如<code>$&#123;count:?&quot;undefined!&quot;&#125;</code>表示变量<code>count</code>未定义时就中断执行，抛出错误，返回给定的报错信息<code>undefined!</code>。</p>
<p>上面四种语法如果用在脚本中，变量名的部分可以用数字<code>1</code>到<code>9</code>，表示脚本的参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">filename</span><span class="token operator">=</span><span class="token variable">$&#123;1<span class="token operator">:?</span>"filename missing."&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面代码出现在脚本中，<code>1</code>表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。</p>
<h2 id="declare-命令"><a href="#declare-命令" class="headerlink" title="declare 命令"></a>declare 命令</h2><p><code>declare</code>命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。</p>
<p>它的语法形式如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">declare</span> OPTION <span class="token assign-left variable">VARIABLE</span><span class="token operator">=</span>value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>declare</code>命令的主要参数（OPTION）如下。</p>
<ul>
<li><code>-a</code>：声明数组变量。</li>
<li><code>-f</code>：输出所有函数定义。</li>
<li><code>-F</code>：输出所有函数名。</li>
<li><code>-i</code>：声明整数变量。</li>
<li><code>-l</code>：声明变量为小写字母。</li>
<li><code>-p</code>：查看变量信息。</li>
<li><code>-r</code>：声明只读变量。</li>
<li><code>-u</code>：声明变量为大写字母。</li>
<li><code>-x</code>：该变量输出为环境变量。</li>
</ul>
<p><code>declare</code>命令如果用在函数中，声明的变量只在函数内部有效，等同于<code>local</code>命令。</p>
<p>不带任何参数时，<code>declare</code>命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的<code>set</code>命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>（1）<code>-i</code>参数</strong></p>
<p><code>-i</code>参数声明整数变量以后，可以直接进行数学运算。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -i <span class="token assign-left variable">val1</span><span class="token operator">=</span><span class="token number">12</span> <span class="token assign-left variable">val2</span><span class="token operator">=</span><span class="token number">5</span>
$ <span class="token builtin class-name">declare</span> -i result
$ <span class="token assign-left variable">result</span><span class="token operator">=</span>val1*val2
$ <span class="token builtin class-name">echo</span> <span class="token variable">$result</span>
<span class="token number">60</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，如果变量<code>result</code>不声明为整数，<code>val1*val2</code>会被当作字面量，不会进行整数运算。另外，<code>val1</code>和<code>val2</code>其实不需要声明为整数，因为只要<code>result</code>声明为整数，它的赋值就会自动解释为整数运算。</p>
<p>注意，一个变量声明为整数以后，依然可以被改写为字符串。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -i <span class="token assign-left variable">var</span><span class="token operator">=</span><span class="token number">12</span>
$ <span class="token assign-left variable">var</span><span class="token operator">=</span>foo
$ <span class="token builtin class-name">echo</span> <span class="token variable">$var</span>
<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，变量<code>var</code>声明为整数，覆盖以后，Bash 不会报错，但会赋以不确定的值，上面的例子中可能输出0，也可能输出的是3。</p>
<p><strong>（2）<code>-x</code>参数</strong></p>
<p><code>-x</code>参数等同于<code>export</code>命令，可以输出一个变量为子 Shell 的环境变量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -x foo
<span class="token comment"># 等同于</span>
$ <span class="token builtin class-name">export</span> foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>（3）<code>-r</code>参数</strong></p>
<p><code>-r</code>参数可以声明只读变量，无法改变变量值，也不能<code>unset</code>变量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -r <span class="token assign-left variable">bar</span><span class="token operator">=</span><span class="token number">1</span>

$ <span class="token assign-left variable">bar</span><span class="token operator">=</span><span class="token number">2</span>
bash: bar：只读变量
$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">1</span>

$ <span class="token builtin class-name">unset</span> bar
bash: bar：只读变量
$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，后两个赋值语句都会报错，命令执行失败。</p>
<p><strong>（4）<code>-u</code>参数</strong></p>
<p><code>-u</code>参数声明变量为大写字母，可以自动把变量值转成大写字母。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -u foo
$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>upper
$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
UPPER<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>（5）<code>-l</code>参数</strong></p>
<p><code>-l</code>参数声明变量为小写字母，可以自动把变量值转成小写字母。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -l bar
$ <span class="token assign-left variable">bar</span><span class="token operator">=</span>LOWER
$ <span class="token builtin class-name">echo</span> <span class="token variable">$bar</span>
lower<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>（6）<code>-p</code>参数</strong></p>
<p><code>-p</code>参数输出变量信息。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>hello
$ <span class="token builtin class-name">declare</span> -p foo
<span class="token builtin class-name">declare</span> -- <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token string">"hello"</span>
$ <span class="token builtin class-name">declare</span> -p bar
bar：未找到<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>declare -p</code>可以输出已定义变量的值，对于未定义的变量，会提示找不到。</p>
<p>如果不提供变量名，<code>declare -p</code>输出所有变量的信息。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>（7）<code>-f</code>参数</strong></p>
<p><code>-f</code>参数输出当前环境的所有函数，包括它的定义。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>（8）<code>-F</code>参数</strong></p>
<p><code>-F</code>参数输出当前环境的所有函数名，不包含函数定义。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -F<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="readonly-命令"><a href="#readonly-命令" class="headerlink" title="readonly 命令"></a>readonly 命令</h2><p><code>readonly</code>命令等同于<code>declare -r</code>，用来声明只读变量，不能改变变量值，也不能<code>unset</code>变量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">readonly</span> <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">1</span>
$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">2</span>
bash: foo：只读变量
$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，更改只读变量<code>foo</code>会报错，命令执行失败。</p>
<p><code>readonly</code>命令有三个参数。</p>
<ul>
<li><code>-f</code>：声明的变量为函数名。</li>
<li><code>-p</code>：打印出所有的只读变量。</li>
<li><code>-a</code>：声明的变量为数组。</li>
</ul>
<h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><p><code>let</code>命令声明变量时，可以直接执行算术表达式。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">let</span> <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">1</span>+2
$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>let</code>命令可以直接计算<code>1 + 2</code>。</p>
<p><code>let</code>命令的参数表达式如果包含空格，就需要使用引号。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">let</span> <span class="token string">"foo = 1 + 2"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>let</code>可以同时对多个变量赋值，赋值表达式之间使用空格分隔。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">let</span> <span class="token string">"v1 = 1"</span> <span class="token string">"v2 = v1++"</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$v1</span>,<span class="token variable">$v2</span>
<span class="token number">2,1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>let</code>声明了两个变量<code>v1</code>和<code>v2</code>，其中<code>v2</code>等于<code>v1++</code>，表示先返回<code>v1</code>的值，然后<code>v1</code>自增。</p>
<p>这种语法支持的运算符，参考《Bash 的算术运算》一章。</p>
<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><p>本章介绍 Bash 字符串操作的语法。</p>
<h2 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h2><p>获取字符串长度的语法如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$&#123;<span class="token operator">#</span>varname&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>下面是一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">myPath</span><span class="token operator">=</span>/home/cam/book/long.file.name
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token operator">#</span>myPath&#125;</span>
<span class="token number">29</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>大括号<code>&#123;&#125;</code>是必需的，否则 Bash 会将<code>$#</code>理解成脚本的参数个数，将变量名理解成文本。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable">$#</span>myvar
0myvar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，Bash 将<code>$#</code>和<code>myvar</code>分开解释了。</p>
<h2 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h2><p>字符串提取子串的语法如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$&#123;varname<span class="token operator">:</span>offset<span class="token operator">:</span>length&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面语法的含义是返回变量<code>$varname</code>的子字符串，从位置<code>offset</code>开始（从<code>0</code>开始计算），长度为<code>length</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">count</span><span class="token operator">=</span>frogfootman
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;count<span class="token operator">:</span>4<span class="token operator">:</span>4&#125;</span>
foot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子返回字符串<code>frogfootman</code>从4号位置开始的长度为4的子字符串<code>foot</code>。</p>
<p>这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。变量前面的美元符号可以省略。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 报错</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;"hello"<span class="token operator">:</span>2<span class="token operator">:</span>3&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，<code>&quot;hello&quot;</code>不是变量名，导致 Bash 报错。</p>
<p>如果省略<code>length</code>，则从位置<code>offset</code>开始，一直返回到字符串的结尾。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">count</span><span class="token operator">=</span>frogfootman
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;count<span class="token operator">:</span>4&#125;</span>
footman<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子是返回变量<code>count</code>从4号位置一直到结尾的子字符串。</p>
<p>如果<code>offset</code>为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格， 以防止与<code>$&#123;variable:-word&#125;</code>的变量的设置默认值语法混淆。这时还可以指定<code>length</code>，<code>length</code>可以是正值，也可以是负值（负值不能超过<code>offset</code>的长度）。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token string">"This string is long."</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token operator">:</span> -5&#125;</span>
long.
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token operator">:</span> -5<span class="token operator">:</span>2&#125;</span>
lo
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token operator">:</span> -5<span class="token operator">:-</span>2&#125;</span>
lon<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>offset</code>为<code>-5</code>，表示从倒数第5个字符开始截取，所以返回<code>long.</code>。如果指定长度<code>length</code>为<code>2</code>，则返回<code>lo</code>；如果<code>length</code>为<code>-2</code>，表示要排除从字符串末尾开始的2个字符，所以返回<code>lon</code>。</p>
<h2 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h2><p>Bash 提供字符串搜索和替换的多种方法。</p>
<p><strong>（1）字符串头部的模式匹配。</strong></p>
<p>以下两种语法可以检查字符串开头，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 如果 pattern 匹配变量 variable 的开头，</span>
<span class="token comment"># 删除最短匹配（非贪婪匹配）的部分，返回剩余部分</span>
<span class="token variable">$&#123;variable<span class="token operator">#</span>pattern&#125;</span>

<span class="token comment"># 如果 pattern 匹配变量 variable 的开头，</span>
<span class="token comment"># 删除最长匹配（贪婪匹配）的部分，返回剩余部分</span>
<span class="token variable">$&#123;variable<span class="token operator">##</span>pattern&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面两种语法会删除变量字符串开头的匹配部分（将其替换为空），返回剩下的部分。区别是一个是最短匹配（又称非贪婪匹配），另一个是最长匹配（又称贪婪匹配）。</p>
<p>匹配模式<code>pattern</code>可以使用<code>*</code>、<code>?</code>、<code>[]</code>等通配符。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">myPath</span><span class="token operator">=</span>/home/cam/book/long.file.name

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;myPath<span class="token operator">#</span><span class="token operator">/</span>*<span class="token operator">/</span>&#125;</span>
cam/book/long.file.name

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;myPath<span class="token operator">##</span><span class="token operator">/</span>*<span class="token operator">/</span>&#125;</span>
long.file.name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，匹配的模式是<code>/*/</code>，其中<code>*</code>可以匹配任意数量的字符，所以最短匹配是<code>/home/</code>，最长匹配是<code>/home/cam/book/</code>。</p>
<p>下面写法可以删除文件路径的目录部分，只留下文件名。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">path</span><span class="token operator">=</span>/home/cam/book/long.file.name

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;path<span class="token operator">##</span>*<span class="token operator">/</span>&#125;</span>
long.file.name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，模式<code>*/</code>匹配目录部分，所以只返回文件名。</p>
<p>下面再看一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">phone</span><span class="token operator">=</span><span class="token string">"555-456-1414"</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;phone<span class="token operator">#</span>*-&#125;</span>
<span class="token number">456</span>-1414
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;phone<span class="token operator">##</span>*-&#125;</span>
<span class="token number">1414</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果匹配不成功，则返回原始字符串。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">phone</span><span class="token operator">=</span><span class="token string">"555-456-1414"</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;phone<span class="token operator">#</span>444&#125;</span>
<span class="token number">555</span>-456-1414<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，原始字符串里面无法匹配模式<code>444</code>，所以原样返回。</p>
<p>如果要将头部匹配的部分，替换成其他内容，采用下面的写法。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 模式必须出现在字符串的开头</span>
<span class="token variable">$&#123;variable<span class="token operator">/</span><span class="token operator">#</span>pattern<span class="token operator">/</span>string&#125;</span>

<span class="token comment"># 示例</span>
$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>JPG.JPG
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token operator">/</span><span class="token operator">#</span>JPG<span class="token operator">/</span>jpg&#125;</span>
jpg.JPG<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，被替换的<code>JPG</code>必须出现在字符串头部，所以返回<code>jpg.JPG</code>。</p>
<p><strong>（2）字符串尾部的模式匹配。</strong></p>
<p>以下两种语法可以检查字符串结尾，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 如果 pattern 匹配变量 variable 的结尾，</span>
<span class="token comment"># 删除最短匹配（非贪婪匹配）的部分，返回剩余部分</span>
<span class="token variable">$&#123;variable<span class="token operator">%</span>pattern&#125;</span>

<span class="token comment"># 如果 pattern 匹配变量 variable 的结尾，</span>
<span class="token comment"># 删除最长匹配（贪婪匹配）的部分，返回剩余部分</span>
<span class="token variable">$&#123;variable<span class="token operator">%%</span>pattern&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面两种语法会删除变量字符串结尾的匹配部分（将其替换为空），返回剩下的部分。区别是一个是最短匹配（又称非贪婪匹配），另一个是最长匹配（又称贪婪匹配）。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">path</span><span class="token operator">=</span>/home/cam/book/long.file.name

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;path<span class="token operator">%</span>.*&#125;</span>
/home/cam/book/long.file

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;path<span class="token operator">%%</span>.*&#125;</span>
/home/cam/book/long<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，匹配模式是<code>.*</code>，其中<code>*</code>可以匹配任意数量的字符，所以最短匹配是<code>.name</code>，最长匹配是<code>.file.name</code>。</p>
<p>下面写法可以删除路径的文件名部分，只留下目录部分。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">path</span><span class="token operator">=</span>/home/cam/book/long.file.name

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;path<span class="token operator">%</span><span class="token operator">/</span>*&#125;</span>
/home/cam/book<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，模式<code>/*</code>匹配文件名部分，所以只返回目录部分。</p>
<p>下面的写法可以替换文件的后缀名。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">file</span><span class="token operator">=</span>foo.png
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;file<span class="token operator">%</span>.png&#125;</span>.jpg
foo.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面的例子将文件的后缀名，从<code>.png</code>改成了<code>.jpg</code>。</p>
<p>下面再看一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">phone</span><span class="token operator">=</span><span class="token string">"555-456-1414"</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;phone<span class="token operator">%</span>-*&#125;</span>
<span class="token number">555</span>-456
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;phone<span class="token operator">%%</span>-*&#125;</span>
<span class="token number">555</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果匹配不成功，则返回原始字符串。</p>
<p>如果要将尾部匹配的部分，替换成其他内容，采用下面的写法。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 模式必须出现在字符串的结尾</span>
<span class="token variable">$&#123;variable<span class="token operator">/</span><span class="token operator">%</span>pattern<span class="token operator">/</span>string&#125;</span>

<span class="token comment"># 示例</span>
$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>JPG.JPG
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token operator">/</span><span class="token operator">%</span>JPG<span class="token operator">/</span>jpg&#125;</span>
JPG.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，被替换的<code>JPG</code>必须出现在字符串尾部，所以返回<code>JPG.jpg</code>。</p>
<p><strong>（3）任意位置的模式匹配。</strong></p>
<p>以下两种语法可以检查字符串内部，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，换成其他的字符串返回。原始变量不会发生变化。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 如果 pattern 匹配变量 variable 的一部分，</span>
<span class="token comment"># 最长匹配（贪婪匹配）的那部分被 string 替换，但仅替换第一个匹配</span>
<span class="token variable">$&#123;variable<span class="token operator">/</span>pattern<span class="token operator">/</span>string&#125;</span>

<span class="token comment"># 如果 pattern 匹配变量 variable 的一部分，</span>
<span class="token comment"># 最长匹配（贪婪匹配）的那部分被 string 替换，所有匹配都替换</span>
<span class="token variable">$&#123;variable<span class="token operator">/</span><span class="token operator">/</span>pattern<span class="token operator">/</span>string&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面两种语法都是最长匹配（贪婪匹配）下的替换，区别是前一个语法仅仅替换第一个匹配，后一个语法替换所有匹配。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">path</span><span class="token operator">=</span>/home/cam/foo/foo.name

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;path<span class="token operator">/</span>foo<span class="token operator">/</span>bar&#125;</span>
/home/cam/bar/foo.name

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;path<span class="token operator">/</span><span class="token operator">/</span>foo<span class="token operator">/</span>bar&#125;</span>
/home/cam/bar/bar.name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，前一个命令只替换了第一个<code>foo</code>，后一个命令将两个<code>foo</code>都替换了。</p>
<p>下面的例子将分隔符从<code>:</code>换成换行符。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> -e <span class="token variable">$&#123;<span class="token environment constant">PATH</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">:</span><span class="token operator">/</span>'\n'&#125;</span>
/usr/local/bin
/usr/bin
/bin
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>echo</code>命令的<code>-e</code>参数，表示将替换后的字符串的<code>\n</code>字符，解释为换行符。</p>
<p>模式部分可以使用通配符。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">phone</span><span class="token operator">=</span><span class="token string">"555-456-1414"</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;phone<span class="token operator">/</span>5?4<span class="token operator">/</span>-&#125;</span>
<span class="token number">55</span>-56-1414<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面的例子将<code>5-4</code>替换成<code>-</code>。</p>
<p>如果省略了<code>string</code>部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">path</span><span class="token operator">=</span>/home/cam/foo/foo.name

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;path<span class="token operator">/</span>.*<span class="token operator">/</span>&#125;</span>
/home/cam/foo/foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，第二个斜杠后面的<code>string</code>部分省略了，所以模式<code>.*</code>匹配的部分<code>.name</code>被删除后返回。</p>
<p>前面提到过，这个语法还有两种扩展形式。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 模式必须出现在字符串的开头</span>
<span class="token variable">$&#123;variable<span class="token operator">/</span><span class="token operator">#</span>pattern<span class="token operator">/</span>string&#125;</span>

<span class="token comment"># 模式必须出现在字符串的结尾</span>
<span class="token variable">$&#123;variable<span class="token operator">/</span><span class="token operator">%</span>pattern<span class="token operator">/</span>string&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a>改变大小写</h2><p>下面的语法可以改变变量的大小写。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 转为大写</span>
<span class="token variable">$&#123;varname<span class="token operator">^^</span>&#125;</span>

<span class="token comment"># 转为小写</span>
<span class="token variable">$&#123;varname<span class="token operator">,,</span>&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面是一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>heLLo
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token operator">^^</span>&#125;</span>
HELLO
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token operator">,,</span>&#125;</span>
hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h1><h2 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h2><p><code>((...))</code>语法可以进行整数的算术运算。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token variable"><span class="token punctuation">((</span>foo <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">))</span></span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
<span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>((...))</code>会自动忽略内部的空格，所以下面的写法都正确，得到同样的结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token variable"><span class="token punctuation">((</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">))</span></span>
$ <span class="token variable"><span class="token punctuation">((</span> <span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span> <span class="token punctuation">))</span></span>
$ <span class="token variable"><span class="token punctuation">((</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token punctuation">))</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是<code>0</code>，命令就算执行成功。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token variable"><span class="token punctuation">((</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token punctuation">))</span></span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>3 + 2</code>的结果是5，命令就算执行成功，环境变量<code>$?</code>为<code>0</code>。</p>
<p>如果算术结果为<code>0</code>，命令就算执行失败。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token variable"><span class="token punctuation">((</span> <span class="token number">3</span> <span class="token operator">-</span> <span class="token number">3</span> <span class="token punctuation">))</span></span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>3 - 3</code>的结果是<code>0</code>，环境变量<code>$?</code>为<code>1</code>，表示命令执行失败。</p>
<p>如果要读取算术运算的结果，需要在<code>((...))</code>前面加上美元符号<code>$((...))</code>，使其变成算术表达式，返回算术运算的值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token variable">))</span></span>
<span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>((...))</code>语法支持的算术运算符如下。</p>
<ul>
<li><code>+</code>：加法</li>
<li><code>-</code>：减法</li>
<li><code>*</code>：乘法</li>
<li><code>/</code>：除法（整除）</li>
<li><code>%</code>：余数</li>
<li><code>**</code>：指数</li>
<li><code>++</code>：自增运算（前缀或后缀）</li>
<li><code>--</code>：自减运算（前缀或后缀）</li>
</ul>
<p>注意，除法运算符的返回结果总是整数，比如<code>5</code>除以<code>2</code>，得到的结果是<code>2</code>，而不是<code>2.5</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">5</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token variable">))</span></span>
<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>++</code>和<code>--</code>这两个运算符有前缀和后缀的区别。作为前缀是先运算后返回值，作为后缀是先返回值后运算。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">0</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$i</span>
<span class="token number">0</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>i<span class="token operator">++</span><span class="token variable">))</span></span>
<span class="token number">0</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$i</span>
<span class="token number">1</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token operator">++</span>i<span class="token variable">))</span></span>
<span class="token number">2</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$i</span>
<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>++</code>作为后缀是先返回值，执行<code>echo</code>命令，再进行自增运算；作为前缀则是先进行自增运算，再返回值执行<code>echo</code>命令。</p>
<p><code>$((...))</code>内部可以用圆括号改变运算顺序。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token variable">))</span></span>
<span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，内部的圆括号让加法先于乘法执行。</p>
<p><code>$((...))</code>结构可以嵌套。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token variable">))</span></span>
<span class="token number">75</span>
<span class="token comment"># 等同于</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token variable">$((</span><span class="token number">5</span><span class="token operator">**</span><span class="token number">2</span><span class="token variable">))</span></span> * <span class="token number">3</span><span class="token punctuation">))</span>
<span class="token number">75</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个语法只能计算整数，否则会报错。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 报错</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">1.5</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token variable">))</span></span>
bash: 语法错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>$((...))</code>的圆括号之中，不需要在变量名之前加上<code>$</code>，不过加上也不报错。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token number">2</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>$number <span class="token operator">+</span> <span class="token number">1</span><span class="token variable">))</span></span>
<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，变量<code>number</code>前面有没有美元符号，结果都是一样的。</p>
<p>如果在<code>$((...))</code>里面使用字符串，Bash 会认为那是一个变量名。如果不存在同名变量，Bash 就会将其作为空值，因此不会报错。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span> "hello" <span class="token operator">+</span> <span class="token number">2</span><span class="token variable">))</span></span>
<span class="token number">2</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span> "hello" <span class="token operator">*</span> <span class="token number">2</span><span class="token variable">))</span></span>
<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>&quot;hello&quot;</code>会被当作变量名，返回空值，而<code>$((...))</code>会将空值当作<code>0</code>，所以乘法的运算结果就是<code>0</code>。同理，如果<code>$((...))</code>里面使用不存在的变量，也会当作<code>0</code>处理。</p>
<p>如果一个变量的值为字符串，跟上面的处理逻辑是一样的。即该字符串如果不对应已存在的变量，在<code>$((...))</code>里面会被当作空值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>hello
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span> foo <span class="token operator">+</span> <span class="token number">2</span><span class="token variable">))</span></span>
<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，变量<code>foo</code>的值是<code>hello</code>，而<code>hello</code>也会被看作变量名。这使得有可能写出动态替换的代码。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>hello
$ <span class="token assign-left variable">hello</span><span class="token operator">=</span><span class="token number">3</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span> foo <span class="token operator">+</span> <span class="token number">2</span> <span class="token variable">))</span></span>
<span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>foo + 2</code>取决于变量<code>hello</code>的值。</p>
<p>最后，<code>$[...]</code>是以前的语法，也可以做整数运算，不建议使用。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> $<span class="token punctuation">[</span><span class="token number">2</span>+2<span class="token punctuation">]</span>
<span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="数值的进制"><a href="#数值的进制" class="headerlink" title="数值的进制"></a>数值的进制</h2><p>Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。</p>
<ul>
<li><code>number</code>：没有任何特殊表示法的数字是十进制数（以10为底）。</li>
<li><code>0number</code>：八进制数。</li>
<li><code>0xnumber</code>：十六进制数。</li>
<li><code>base#number</code>：<code>base</code>进制的数。</li>
</ul>
<p>下面是一些例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">0xff</span><span class="token variable">))</span></span>
<span class="token number">255</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">2</span>#<span class="token number">11111111</span><span class="token variable">))</span></span>
<span class="token number">255</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>0xff</code>是十六进制数，<code>2#11111111</code>是二进制数。</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><code>$((...))</code>支持以下的二进制位运算符。</p>
<ul>
<li><code>&lt;&lt;</code>：位左移运算，把一个数字的所有位向左移动指定的位。</li>
<li><code>&gt;&gt;</code>：位右移运算，把一个数字的所有位向右移动指定的位。</li>
<li><code>&amp;</code>：位的“与”运算，对两个数字的所有位执行一个<code>AND</code>操作。</li>
<li><code>|</code>：位的“或”运算，对两个数字的所有位执行一个<code>OR</code>操作。</li>
<li><code>~</code>：位的“否”运算，对一个数字的所有位取反。</li>
<li><code>^</code>：位的异或运算（exclusive or），对两个数字的所有位执行一个异或操作。</li>
</ul>
<p>下面是右移运算符<code>&gt;&gt;</code>的例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">16</span><span class="token operator">>></span><span class="token number">2</span><span class="token variable">))</span></span>
<span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>下面是左移运算符<code>&lt;&lt;</code>的例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">16</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token variable">))</span></span>
<span class="token number">64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>下面是<code>17</code>（二进制<code>10001</code>）和<code>3</code>（二进制<code>11</code>）的各种二进制运算的结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">17</span><span class="token operator">&amp;</span><span class="token number">3</span><span class="token variable">))</span></span>
<span class="token number">1</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">17</span><span class="token operator">|</span><span class="token number">3</span><span class="token variable">))</span></span>
<span class="token number">19</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">17</span><span class="token operator">^</span><span class="token number">3</span><span class="token variable">))</span></span>
<span class="token number">18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p><code>$((...))</code>支持以下的逻辑运算符。</p>
<ul>
<li><code>&lt;</code>：小于</li>
<li><code>&gt;</code>：大于</li>
<li><code>&lt;=</code>：小于或相等</li>
<li><code>&gt;=</code>：大于或相等</li>
<li><code>==</code>：相等</li>
<li><code>!=</code>：不相等</li>
<li><code>&amp;&amp;</code>：逻辑与</li>
<li><code>||</code>：逻辑或</li>
<li><code>!</code>：逻辑否</li>
<li><code>expr1?expr2:expr3</code>：三元条件运算符。若表达式<code>expr1</code>的计算结果为非零值（算术真），则执行表达式<code>expr2</code>，否则执行表达式<code>expr3</code>。</li>
</ul>
<p>如果逻辑表达式为真，返回<code>1</code>，否则返回<code>0</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">3</span> <span class="token operator">></span> <span class="token number">2</span><span class="token variable">))</span></span>
<span class="token number">1</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token variable">))</span></span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>三元运算符执行一个单独的逻辑测试。它用起来类似于<code>if/then/else</code>语句。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">0</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>a<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token variable">))</span></span>
<span class="token number">1</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>a<span class="token operator">></span><span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token variable">))</span></span>
<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，第一个表达式为真时，返回第二个表达式的值，否则返回第三个表达式的值。</p>
<h2 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h2><p>算术表达式<code>$((...))</code>可以执行赋值运算。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token variable">))</span></span>
<span class="token number">1</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$a</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>a=1</code>对变量<code>a</code>进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。</p>
<p><code>$((...))</code>支持的赋值运算符，有以下这些。</p>
<ul>
<li><code>parameter = value</code>：简单赋值。</li>
<li><code>parameter += value</code>：等价于<code>parameter = parameter + value</code>。</li>
<li><code>parameter -= value</code>：等价于<code>parameter = parameter – value</code>。</li>
<li><code>parameter *= value</code>：等价于<code>parameter = parameter * value</code>。</li>
<li><code>parameter /= value</code>：等价于<code>parameter = parameter / value</code>。</li>
<li><code>parameter %= value</code>：等价于<code>parameter = parameter % value</code>。</li>
<li><code>parameter &lt;&lt;= value</code>：等价于<code>parameter = parameter &lt;&lt; value</code>。</li>
<li><code>parameter &gt;&gt;= value</code>：等价于<code>parameter = parameter &gt;&gt; value</code>。</li>
<li><code>parameter &amp;= value</code>：等价于<code>parameter = parameter &amp; value</code>。</li>
<li><code>parameter |= value</code>：等价于<code>parameter = parameter | value</code>。</li>
<li><code>parameter ^= value</code>：等价于<code>parameter = parameter ^ value</code>。</li>
</ul>
<p>下面是一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">5</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>foo<span class="token operator">*</span><span class="token operator">=</span><span class="token number">2</span><span class="token variable">))</span></span>
<span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>如果在表达式内部赋值，可以放在圆括号中，否则会报错。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span> a<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token operator">-</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token variable">))</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="求值运算"><a href="#求值运算" class="headerlink" title="求值运算"></a>求值运算</h2><p>逗号<code>,</code>在<code>$((...))</code>内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>foo <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token variable">))</span></span>
<span class="token number">12</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，逗号前后两个表达式都会执行，然后返回后一个表达式的值<code>12</code>。</p>
<h2 id="expr-命令"><a href="#expr-命令" class="headerlink" title="expr 命令"></a>expr 命令</h2><p><code>expr</code>命令支持算术运算，可以不使用<code>((...))</code>语法。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">expr</span> <span class="token number">3</span> + <span class="token number">2</span>
<span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>expr</code>命令支持变量替换。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">3</span>
$ <span class="token function">expr</span> <span class="token variable">$foo</span> + <span class="token number">2</span>
<span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>expr</code>命令也不支持非整数参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">expr</span> <span class="token number">3.5</span> + <span class="token number">2</span>
expr: 非整数参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，如果有非整数的运算，<code>expr</code>命令就报错了。</p>
<h2 id="let-命令-1"><a href="#let-命令-1" class="headerlink" title="let 命令"></a>let 命令</h2><p><code>let</code>命令用于将算术运算的结果，赋予一个变量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">let</span> <span class="token assign-left variable">x</span><span class="token operator">=</span><span class="token number">2</span>+3
$ <span class="token builtin class-name">echo</span> <span class="token variable">$x</span>
<span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，变量<code>x</code>等于<code>2+3</code>的运算结果。</p>
<p>注意，<code>x=2+3</code>这个式子里面不能有空格，否则会报错。<code>let</code>命令的详细用法参见《变量》一章。</p>
<h1 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能，比如命令的自动补全，可以大大加快操作速度。</p>
<p>这个库默认采用 Emacs 快捷键，也可以改成 Vi 快捷键。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">set</span> -o <span class="token function">vi</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>下面的命令可以改回 Emacs 快捷键。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">set</span> -o emacs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果想永久性更改编辑模式（Emacs / Vi），可以将命令写在<code>~/.inputrc</code>文件，这个文件是 Readline 的配置文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> editing-mode <span class="token function">vi</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>本章介绍的快捷键都属于 Emacs 模式。Vi 模式的快捷键，读者可以参考 Vi 编辑器的教程。</p>
<p>Bash 默认开启这个库，但是允许关闭。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> --noediting<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令中，<code>--noediting</code>参数关闭了 Readline 库，启动的 Bash 就不带有行操作功能。</p>
<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><p>Readline 提供快速移动光标的快捷键。</p>
<ul>
<li><code>Ctrl + a</code>：移到行首。</li>
<li><code>Ctrl + b</code>：向行首移动一个字符，与左箭头作用相同。</li>
<li><code>Ctrl + e</code>：移到行尾。</li>
<li><code>Ctrl + f</code>：向行尾移动一个字符，与右箭头作用相同。</li>
<li><code>Alt + f</code>：移动到当前单词的词尾。</li>
<li><code>Alt + b</code>：移动到当前单词的词首。</li>
</ul>
<p>上面快捷键的 Alt 键，也可以用 ESC 键代替。</p>
<h2 id="清除屏幕"><a href="#清除屏幕" class="headerlink" title="清除屏幕"></a>清除屏幕</h2><p><code>Ctrl + l</code>快捷键可以清除屏幕，即将当前行移到屏幕的第一行，与<code>clear</code>命令作用相同。</p>
<h2 id="编辑操作"><a href="#编辑操作" class="headerlink" title="编辑操作"></a>编辑操作</h2><p>下面的快捷键可以编辑命令行内容。</p>
<ul>
<li><code>Ctrl + d</code>：删除光标位置的字符（delete）。</li>
<li><code>Ctrl + w</code>：删除光标前面的单词。</li>
<li><code>Ctrl + t</code>：光标位置的字符与它前面一位的字符交换位置（transpose）。</li>
<li><code>Alt + t</code>：光标位置的词与它前面一位的词交换位置（transpose）。</li>
<li><code>Alt + l</code>：将光标位置至词尾转为小写（lowercase）。</li>
<li><code>Alt + u</code>：将光标位置至词尾转为大写（uppercase）。</li>
</ul>
<p>使用<code>Ctrl + d</code>的时候，如果当前行没有任何字符，会导致退出当前 Shell，所以要小心。</p>
<p>剪切和粘贴快捷键如下。</p>
<ul>
<li><code>Ctrl + k</code>：剪切光标位置到行尾的文本。</li>
<li><code>Ctrl + u</code>：剪切光标位置到行首的文本。</li>
<li><code>Alt + d</code>：剪切光标位置到词尾的文本。</li>
<li><code>Alt + Backspace</code>：剪切光标位置到词首的文本。</li>
<li><code>Ctrl + y</code>：在光标位置粘贴文本。</li>
</ul>
<p>同样地，Alt 键可以用 Esc 键代替。</p>
<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>命令输入到一半的时候，可以按一下 Tab 键，Readline 会自动补全命令或路径。比如，输入<code>cle</code>，再按下 Tab 键，Bash 会自动将这个命令补全为<code>clear</code>。</p>
<p>如果符合条件的命令或路径有多个，就需要连续按两次 Tab 键，Bash 会提示所有符合条件的命令或路径。</p>
<p>除了命令或路径，Tab 还可以补全其他值。如果一个值以<code>$</code>开头，则按下 Tab 键会补全变量；如果以<code>~</code>开头，则补全用户名；如果以<code>@</code>开头，则补全主机名（hostname），主机名以列在<code>/etc/hosts</code>文件里面的主机为准。</p>
<p>自动补全相关的快捷键如下。</p>
<ul>
<li>Tab：完成自动补全。</li>
<li><code>Alt + ?</code>：列出可能的补全，与连按两次 Tab 键作用相同。</li>
<li><code>Alt + /</code>：尝试文件路径补全。</li>
<li><code>Ctrl + x /</code>：先按<code>Ctrl + x</code>，再按<code>/</code>，等同于<code>Alt + ?</code>，列出可能的文件路径补全。</li>
<li><code>Alt + !</code>：命令补全。</li>
<li><code>Ctrl + x !</code>：先按<code>Ctrl + x</code>，再按<code>!</code>，等同于<code>Alt + !</code>，命令补全。</li>
<li><code>Alt + ~</code>：用户名补全。</li>
<li><code>Ctrl + x ~</code>：先按<code>Ctrl + x</code>，再按<code>~</code>，等同于<code>Alt + ~</code>，用户名补全。</li>
<li><code>Alt + $</code>：变量名补全。</li>
<li><code>Ctrl + x $</code>：先按<code>Ctrl + x</code>，再按<code>$</code>，等同于<code>Alt + $</code>，变量名补全。</li>
<li><code>Alt + @</code>：主机名补全。</li>
<li><code>Ctrl + x @</code>：先按<code>Ctrl + x</code>，再按<code>@</code>，等同于<code>Alt + @</code>，主机名补全。</li>
<li><code>Alt + *</code>：在命令行一次性插入所有可能的补全。</li>
<li><code>Alt + Tab</code>：尝试用<code>.bash_history</code>里面以前执行命令，进行补全。</li>
</ul>
<p>上面的<code>Alt</code>键也可以用 ESC 键代替。</p>
<h2 id="操作历史"><a href="#操作历史" class="headerlink" title="操作历史"></a>操作历史</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Bash 会保留用户的操作历史，即用户输入的每一条命令都会记录。有了操作历史以后，就可以使用方向键的<code>↑</code>和<code>↓</code>，快速浏览上一条和下一条命令。</p>
<p>退出当前 Shell 的时候，Bash 会将用户在当前 Shell 的操作历史写入<code>~/.bash_history</code>文件，该文件默认储存500个操作。</p>
<p>环境变量<code>HISTFILE</code>总是指向这个文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$HISTFILE</span>
/home/me/.bash_history<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>history</code>命令会输出这个文件的全部内容。用户可以看到最近执行过的所有命令，每条命令之前都有行号。越近的命令，排在越后面。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">history</span>
<span class="token punctuation">..</span>.
<span class="token number">498</span> <span class="token builtin class-name">echo</span> Goodbye
<span class="token number">499</span> <span class="token function">ls</span> ~
<span class="token number">500</span> <span class="token builtin class-name">cd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输入命令时，按下<code>Ctrl + r</code>快捷键，就可以搜索操作历史，选择以前执行过的命令。这时键入命令的开头部分，Shell 就会自动在历史文件中，查询并显示最近一条匹配的结果，这时按下回车键，就会执行那条命令。</p>
<p>下面的方法可以快速执行以前执行过的命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> Hello World
Hello World

$ <span class="token builtin class-name">echo</span> Goodbye
Goodbye

$ <span class="token operator">!</span>e
<span class="token builtin class-name">echo</span> Goodbye
Goodbye<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>!e</code>表示找出操作历史之中，最近的那一条以<code>e</code>开头的命令并执行。Bash 会先输出那一条命令<code>echo Goodbye</code>，然后直接执行。</p>
<p>同理，<code>!echo</code>也会执行最近一条以<code>echo</code>开头的命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token operator">!</span>echo
<span class="token builtin class-name">echo</span> Goodbye
Goodbye

$ <span class="token operator">!</span>echo H
<span class="token builtin class-name">echo</span> Goodbye H
Goodbye H

$ <span class="token operator">!</span>echo H G
<span class="token builtin class-name">echo</span> Goodbye H G
Goodbye H G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，<code>!string</code>语法只会匹配命令，不会匹配参数。所以<code>!echo H</code>不会执行<code>echo Hello World</code>，而是会执行<code>echo Goodbye</code>，并把参数<code>H</code>附加在这条命令之后。同理，<code>!echo H G</code>也是等同于<code>echo Goodbye</code>命令之后附加<code>H G</code>。</p>
<p>由于<code>!string</code>语法会扩展成以前执行过的命令，所以含有<code>!</code>的字符串放在双引号里面，必须非常小心，如果它后面有非空格的字符，就很有可能报错。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"I say:<span class="token entity" title="\&quot;">\"</span>hello!<span class="token entity" title="\&quot;">\"</span>"</span>
bash: <span class="token operator">!</span><span class="token punctuation">\</span>: event not found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面的命令会报错，原因是感叹号后面是一个反斜杠，Bash 会尝试寻找，以前是否执行过反斜杠开头的命令，一旦找不到就会报错。解决方法就是在感叹号前面，也加上反斜杠。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"I say:<span class="token entity" title="\&quot;">\"</span>hello\!<span class="token entity" title="\&quot;">\"</span>"</span>
I say:<span class="token string">"hello\!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="history-命令"><a href="#history-命令" class="headerlink" title="history 命令"></a>history 命令</h3><p>前面说过，<code>history</code>命令能显示操作历史，即<code>.bash_history</code>文件的内容。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">history</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用该命令，而不是直接读取<code>.bash_history</code>文件的好处是，它会在所有的操作前加上行号，最近的操作在最后面，行号最大。</p>
<p>通过定制环境变量<code>HISTTIMEFORMAT</code>，可以显示每个操作的时间。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">export</span> <span class="token assign-left variable">HISTTIMEFORMAT</span><span class="token operator">=</span><span class="token string">'%F %T  '</span>
$ <span class="token function">history</span>
<span class="token number">1</span>  <span class="token number">2013</span>-06-09 <span class="token number">10</span>:40:12   <span class="token function">cat</span> /etc/issue
<span class="token number">2</span>  <span class="token number">2013</span>-06-09 <span class="token number">10</span>:40:12   <span class="token function">clear</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>%F</code>相当于<code>%Y - %m - %d</code>，<code>%T</code>相当于<code> %H : %M : %S</code>。</p>
<p>只要设置<code>HISTTIMEFORMAT</code>这个环境变量，就会在<code>.bash_history</code>文件保存命令的执行时间戳。如果不设置，就不会保存时间戳。</p>
<p>环境变量<code>HISTSIZE</code>设置保存历史操作的数量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">HISTSIZE</span></span><span class="token operator">=</span><span class="token number">10000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令设置保存过去10000条操作历史。</p>
<p>如果不希望保存本次操作的历史，可以设置<code>HISTSIZE</code>等于0。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">HISTSIZE</span></span><span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果<code>HISTSIZE=0</code>写入用户主目录的<code>~/.bashrc</code>文件，那么就不会保留该用户的操作历史。如果写入<code>/etc/profile</code>，整个系统都不会保留操作历史。</p>
<p>环境变量<code>HISTIGNORE</code>可以设置哪些命令不写入操作历史。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">HISTIGNORE</span><span class="token operator">=</span><span class="token string">'pwd:ls:exit'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面示例设置，<code>pwd</code>、<code>ls</code>、<code>exit</code>这三个命令不写入操作历史。</p>
<p>如果想搜索某个以前执行的命令，可以配合<code>grep</code>命令搜索操作历史。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">history</span> <span class="token operator">|</span> <span class="token function">grep</span> /usr/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令返回<code>.bash_history</code>文件里面，那些包含<code>/usr/bin</code>的命令。</p>
<p>操作历史的每一条记录都有编号。知道了命令的编号以后，可以用<code>感叹号 + 编号</code>执行该命令。如果想要执行<code>.bash_history</code>里面的第8条命令，可以像下面这样操作。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token operator">!</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>history</code>命令的<code>-c</code>参数可以清除操作历史。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">history</span> -c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="相关快捷键"><a href="#相关快捷键" class="headerlink" title="相关快捷键"></a>相关快捷键</h3><p>下面是一些与操作历史相关的快捷键。</p>
<ul>
<li><code>Ctrl + p</code>：显示上一个命令，与向上箭头效果相同（previous）。</li>
<li><code>Ctrl + n</code>：显示下一个命令，与向下箭头效果相同（next）。</li>
<li><code>Alt + &lt;</code>：显示第一个命令。</li>
<li><code>Alt + &gt;</code>：显示最后一个命令，即当前的命令。</li>
<li><code>Ctrl + o</code>：执行历史文件里面的当前条目，并自动显示下一条命令。这对重复执行某个序列的命令很有帮助。</li>
</ul>
<p>感叹号<code>!</code>的快捷键如下。</p>
<ul>
<li><code>!!</code>：执行上一个命令。</li>
<li><code>!n</code>：<code>n</code>为数字，执行历史文件里面行号为<code>n</code>的命令。</li>
<li><code>!-n</code>：执行当前命令之前<code>n</code>条的命令。</li>
<li><code>!string</code>：执行最近一个以指定字符串<code>string</code>开头的命令。</li>
<li><code>!?string</code>：执行最近一条包含字符串<code>string</code>的命令。</li>
<li><code>!$</code>：代表上一个命令的最后一个参数。</li>
<li><code>!*</code>：代表上一个命令的所有参数，即除了命令以外的所有部分。</li>
<li><code>^string1^string2</code>：执行最近一条包含<code>string1</code>的命令，将其替换成<code>string2</code>。</li>
</ul>
<p>下面是<code>!$</code>和<code>!*</code>的例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cp</span> a.txt b.txt
$ <span class="token builtin class-name">echo</span> <span class="token operator">!</span>$
b.txt

$ <span class="token function">cp</span> a.txt b.txt
$ <span class="token builtin class-name">echo</span> <span class="token operator">!</span>*
a.txt b.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面示例中，<code>!$</code>代表上一个命令的最后一个参数（<code>b.txt</code>），<code>!*</code>代表上一个命令的所有参数（<code>a.txt b.txt</code>）。</p>
<p>下面是<code>^string1^string2</code>的例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> /var/log/httpd/error.log
$ ^error^access
<span class="token function">rm</span> /var/log/httpd/access.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面示例中，<code>^error^access</code>将最近一条含有<code>error</code>的命令里面的<code>error</code>，替换成<code>access</code>。</p>
<p>如果希望确定是什么命令，然后再执行，可以打开<code>histverify</code>选项。这样的话，使用<code>!</code>快捷键所产生的命令，会先打印出来，等到用户按下回车键后再执行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> -s histverify<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h2><ul>
<li><code>Ctrl + j</code>：等同于回车键（LINEFEED）。</li>
<li><code>Ctrl + m</code>：等同于回车键（CARRIAGE RETURN）。</li>
<li><code>Ctrl + o</code>：等同于回车键，并展示操作历史的下一个命令。 </li>
<li><code>Ctrl + v</code>：将下一个输入的特殊字符变成字面量，比如回车变成<code>^M</code>。</li>
<li><code>Ctrl + [</code>：等同于 ESC。 </li>
<li><code>Alt + .</code>：插入上一个命令的最后一个词。</li>
<li><code>Alt + _</code>：等同于<code>Alt + .</code>。</li>
</ul>
<p>上面的<code>Alt + .</code>快捷键，对于很长的文件路径，有时会非常方便。因为 Unix 命令的最后一个参数通常是文件路径。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> foo_bar
$ <span class="token builtin class-name">cd</span> <span class="token comment">#按下 Alt + .</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，在<code>cd</code>命令后按下<code>Alt + .</code>，就会自动插入<code>foo_bar</code>。</p>
<h1 id="目录堆栈"><a href="#目录堆栈" class="headerlink" title="目录堆栈"></a>目录堆栈</h1><p>为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。</p>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd -"></a>cd -</h2><p>Bash 可以记忆用户进入过的目录。默认情况下，只记忆前一次所在的目录，<code>cd -</code>命令可以返回前一次的目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 当前目录是 /path/to/foo</span>
$ <span class="token builtin class-name">cd</span> bar

<span class="token comment"># 重新回到 /path/to/foo</span>
$ <span class="token builtin class-name">cd</span> -<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，用户原来所在的目录是<code>/path/to/foo</code>，进入子目录<code>bar</code>以后，使用<code>cd -</code>可以回到原来的目录。</p>
<h2 id="pushd，popd"><a href="#pushd，popd" class="headerlink" title="pushd，popd"></a>pushd，popd</h2><p>如果希望记忆多重目录，可以使用<code>pushd</code>命令和<code>popd</code>命令。它们用来操作目录堆栈。</p>
<p><code>pushd</code>命令的用法类似<code>cd</code>命令，可以进入指定的目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">pushd</span> <span class="token function">dirname</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令会进入目录<code>dirname</code>，并将该目录放入堆栈。</p>
<p>第一次使用<code>pushd</code>命令时，会将当前目录先放入堆栈，然后将所要进入的目录也放入堆栈，位置在前一个记录的上方。以后每次使用<code>pushd</code>命令，都会将所要进入的目录，放在堆栈的顶部。</p>
<p><code>popd</code>命令不带有参数时，会移除堆栈的顶部记录，并进入新的堆栈顶部目录（即原来的第二条目录）。</p>
<p>下面是一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 当前处在主目录，堆栈为空</span>
$ <span class="token builtin class-name">pwd</span>
/home/me

<span class="token comment"># 进入 /home/me/foo</span>
<span class="token comment"># 当前堆栈为 /home/me/foo /home/me</span>
$ <span class="token function">pushd</span> ~/foo

<span class="token comment"># 进入 /etc</span>
<span class="token comment"># 当前堆栈为 /etc /home/me/foo /home/me</span>
$ <span class="token function">pushd</span> /etc

<span class="token comment"># 进入 /home/me/foo</span>
<span class="token comment"># 当前堆栈为 /home/me/foo /home/me</span>
$ <span class="token function">popd</span>

<span class="token comment"># 进入 /home/me</span>
<span class="token comment"># 当前堆栈为 /home/me</span>
$ <span class="token function">popd</span>

<span class="token comment"># 目录不变，当前堆栈为空</span>
$ <span class="token function">popd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这两个命令的参数如下。</p>
<p><strong>（1）-n 参数</strong></p>
<p><code>-n</code>的参数表示仅操作堆栈，不改变目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">popd</span> -n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的命令仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录。</p>
<p><strong>（2）整数参数</strong></p>
<p>这两个命令还可以接受一个整数作为参数，该整数表示堆栈中指定位置的记录（从0开始），作为操作对象。这时不会切换目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 从栈顶算起的3号目录（从0开始），移动到栈顶</span>
$ <span class="token function">pushd</span> +3

<span class="token comment"># 从栈底算起的3号目录（从0开始），移动到栈顶</span>
$ <span class="token function">pushd</span> -3

<span class="token comment"># 删除从栈顶算起的3号目录（从0开始）</span>
$ <span class="token function">popd</span> +3

<span class="token comment"># 删除从栈底算起的3号目录（从0开始）</span>
$ <span class="token function">popd</span> -3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子的整数编号都是从0开始计算，<code>popd +0</code>是删除第一个目录，<code>popd +1</code>是删除第二个，<code>popd -0</code>是删除最后一个目录，，<code>popd -1</code>是删除倒数第二个。</p>
<p><strong>（3）目录参数</strong></p>
<p><code>pushd</code>可以接受一个目录作为参数，表示将该目录放到堆栈顶部，并进入该目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">pushd</span> <span class="token function">dir</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>popd</code>没有这个参数。</p>
<h2 id="dirs-命令"><a href="#dirs-命令" class="headerlink" title="dirs 命令"></a>dirs 命令</h2><p><code>dirs</code>命令可以显示目录堆栈的内容，一般用来查看<code>pushd</code>和<code>popd</code>操作后的结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">dirs</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>它有以下参数。</p>
<ul>
<li><code>-c</code>：清空目录栈。</li>
<li><code>-l</code>：用户主目录不显示波浪号前缀，而打印完整的目录。</li>
<li><code>-p</code>：每行一个条目打印目录栈，默认是打印在一行。</li>
<li><code>-v</code>：每行一个条目，每个条目之前显示位置编号（从0开始）。</li>
<li><code>+N</code>：<code>N</code>为整数，表示显示堆顶算起的第 N 个目录，从零开始。</li>
<li><code>-N</code>：<code>N</code>为整数，表示显示堆底算起的第 N 个目录，从零开始。</li>
</ul>
<h1 id="脚本入门"><a href="#脚本入门" class="headerlink" title="脚本入门"></a>脚本入门</h1><p>脚本（script）就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。</p>
<p>脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。</p>
<h2 id="Shebang-行"><a href="#Shebang-行" class="headerlink" title="Shebang 行"></a>Shebang 行</h2><p>脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以<code>#!</code>字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。</p>
<p><code>#!</code>后面就是脚本解释器的位置，Bash 脚本的解释器一般是<code>/bin/sh</code>或<code>/bin/bash</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token comment"># 或者</span>
<span class="token comment">#!/bin/bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>#!</code>与脚本解释器之间有没有空格，都是可以的。</p>
<p>如果 Bash 解释器不放在目录<code>/bin</code>，脚本就无法执行了。为了保险，可以写成下面这样。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令使用<code>env</code>命令（这个命令总是在<code>/usr/bin</code>目录），返回 Bash 可执行文件的位置。<code>env</code>命令的详细介绍，请看后文。</p>
<p>Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器。举例来说，脚本是<code>script.sh</code>，有 Shebang 行的时候，可以直接调用执行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./script.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，<code>script.sh</code>是脚本文件名。脚本通常使用<code>.sh</code>后缀名，不过这不是必需的。</p>
<p>如果没有 Shebang 行，就只能手动将脚本传给解释器来执行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ /bin/sh ./script.sh
<span class="token comment"># 或者</span>
$ <span class="token function">bash</span> ./script.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="执行权限和路径"><a href="#执行权限和路径" class="headerlink" title="执行权限和路径"></a>执行权限和路径</h2><p>前面说过，只要指定了 Shebang 行的脚本，可以直接执行。这有一个前提条件，就是脚本需要有执行权限。可以使用下面的命令，赋予脚本执行权限。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 给所有用户执行权限</span>
$ <span class="token function">chmod</span> +x script.sh

<span class="token comment"># 给所有用户读权限和执行权限</span>
$ <span class="token function">chmod</span> +rx script.sh
<span class="token comment"># 或者</span>
$ <span class="token function">chmod</span> <span class="token number">755</span> script.sh

<span class="token comment"># 只给脚本拥有者读权限和执行权限</span>
$ <span class="token function">chmod</span> u+rx script.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>脚本的权限通常设为<code>755</code>（拥有者有所有权限，其他人有读和执行权限）或者<code>700</code>（只有拥有者可以执行）。</p>
<p>除了执行权限，脚本调用时，一般需要指定脚本的路径（比如<code>path/script.sh</code>）。如果将脚本放在环境变量<code>$PATH</code>指定的目录中，就不需要指定路径了。因为 Bash 会自动到这些目录中，寻找是否存在同名的可执行文件。</p>
<p>建议在主目录新建一个<code>~/bin</code>子目录，专门存放可执行脚本，然后把<code>~/bin</code>加入<code>$PATH</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:~/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令改变环境变量<code>$PATH</code>，将<code>~/bin</code>添加到<code>$PATH</code>的末尾。可以将这一行加到<code>~/.bashrc</code>文件里面，然后重新加载一次<code>.bashrc</code>，这个配置就可以生效了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>以后不管在什么目录，直接输入脚本文件名，脚本就会执行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ script.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令没有指定脚本路径，因为<code>script.sh</code>在<code>$PATH</code>指定的目录中。</p>
<h2 id="env-命令"><a href="#env-命令" class="headerlink" title="env 命令"></a>env 命令</h2><p><code>env</code>命令总是指向<code>/usr/bin/env</code>文件，或者说，这个二进制文件总是在目录<code>/usr/bin</code>。</p>
<p><code>#!/usr/bin/env NAME</code>这个语法的意思是，让 Shell 查找<code>$PATH</code>环境变量里面第一个匹配的<code>NAME</code>。如果你不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用。</p>
<p><code>/usr/bin/env bash</code>的意思就是，返回<code>bash</code>可执行文件的位置，前提是<code>bash</code>的路径是在<code>$PATH</code>里面。其他脚本文件也可以使用这个命令。比如 Node.js 脚本的 Shebang 行，可以写成下面这样。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env node</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>env</code>命令的参数如下。</p>
<ul>
<li><code>-i</code>, <code>--ignore-environment</code>：不带环境变量启动。</li>
<li><code>-u</code>, <code>--unset=NAME</code>：从环境变量中删除一个变量。</li>
<li><code>--help</code>：显示帮助。</li>
<li><code>--version</code>：输出版本信息。</li>
</ul>
<p>下面是一个例子，新建一个不带任何环境变量的 Shell。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">env</span> -i /bin/sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Bash 脚本中，<code>#</code>表示注释，可以放在行首，也可以放在行尾。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 本行是注释</span>
<span class="token builtin class-name">echo</span> <span class="token string">'Hello World!'</span>

<span class="token builtin class-name">echo</span> <span class="token string">'Hello World!'</span> <span class="token comment"># 井号后面的部分也是注释</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>建议在脚本开头，使用注释说明当前脚本的作用，这样有利于日后的维护。</p>
<h2 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h2><p>调用脚本的时候，脚本文件名后面可以带有参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ script.sh word1 word2 word3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，<code>script.sh</code>是一个脚本文件，<code>word1</code>、<code>word2</code>和<code>word3</code>是三个参数。</p>
<p>脚本文件内部，可以使用特殊变量，引用这些参数。</p>
<ul>
<li><code>$0</code>：脚本文件名，即<code>script.sh</code>。</li>
<li><code>$1</code>~<code>$9</code>：对应脚本的第一个参数到第九个参数。</li>
<li><code>$#</code>：参数的总数。</li>
<li><code>$@</code>：全部的参数，参数之间使用空格分隔。</li>
<li><code>$*</code>：全部的参数，参数之间使用变量<code>$IFS</code>值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果脚本的参数多于9个，那么第10个参数可以用<code>$&#123;10&#125;</code>的形式引用，以此类推。</p>
<p>注意，如果命令是<code>command -o foo bar</code>，那么<code>-o</code>是<code>$1</code>，<code>foo</code>是<code>$2</code>，<code>bar</code>是<code>$3</code>。</p>
<p>下面是一个脚本内部读取命令行参数的例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># script.sh</span>

<span class="token builtin class-name">echo</span> <span class="token string">"全部参数："</span> <span class="token variable">$@</span>
<span class="token builtin class-name">echo</span> <span class="token string">"命令行参数数量："</span> <span class="token variable">$#</span>
<span class="token builtin class-name">echo</span> <span class="token string">'<span class="token variable">$0</span> = '</span> <span class="token variable">$0</span>
<span class="token builtin class-name">echo</span> <span class="token string">'<span class="token variable">$1</span> = '</span> <span class="token variable">$1</span>
<span class="token builtin class-name">echo</span> <span class="token string">'<span class="token variable">$2</span> = '</span> <span class="token variable">$2</span>
<span class="token builtin class-name">echo</span> <span class="token string">'<span class="token variable">$3</span> = '</span> <span class="token variable">$3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./script.sh a b c
全部参数：a b c
命令行参数数量：3
<span class="token variable">$0</span> <span class="token operator">=</span>  script.sh
<span class="token variable">$1</span> <span class="token operator">=</span>  a
<span class="token variable">$2</span> <span class="token operator">=</span>  b
<span class="token variable">$3</span> <span class="token operator">=</span>  c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>用户可以输入任意数量的参数，利用<code>for</code>循环，可以读取每一个参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$@</span>"</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token variable">$i</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>$@</code>返回一个全部参数的列表，然后使用<code>for</code>循环遍历。</p>
<p>如果多个参数放在双引号里面，视为一个参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./script.sh <span class="token string">"a b"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，Bash 会认为<code>&quot;a b&quot;</code>是一个参数，<code>$1</code>会返回<code>a b</code>。注意，返回时不包括双引号。</p>
<h2 id="shift-命令"><a href="#shift-命令" class="headerlink" title="shift 命令"></a>shift 命令</h2><p><code>shift</code>命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数（<code>$1</code>），使得后面的参数向前一位，即<code>$2</code>变成<code>$1</code>、<code>$3</code>变成<code>$2</code>、<code>$4</code>变成<code>$3</code>，以此类推。</p>
<p><code>while</code>循环结合<code>shift</code>命令，也可以读取每一个参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">echo</span> <span class="token string">"一共输入了 <span class="token variable">$#</span> 个参数"</span>

<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"剩下 <span class="token variable">$#</span> 个参数"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"参数：<span class="token variable">$1</span>"</span>
  <span class="token builtin class-name">shift</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>shift</code>命令每次移除当前第一个参数，从而通过<code>while</code>循环遍历所有参数。</p>
<p><code>shift</code>命令可以接受一个整数作为参数，指定所要移除的参数个数，默认为<code>1</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">shift</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的命令移除前三个参数，原来的<code>$4</code>变成<code>$1</code>。</p>
<h2 id="getopts-命令"><a href="#getopts-命令" class="headerlink" title="getopts 命令"></a>getopts 命令</h2><p><code>getopts</code>命令用在脚本内部，可以解析复杂的脚本命令行参数，通常与<code>while</code>循环一起使用，取出脚本所有的带有前置连词线（<code>-</code>）的参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">getopts</span> optstring name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>它带有两个参数。第一个参数<code>optstring</code>是字符串，给出脚本所有的连词线参数。比如，某个脚本可以有三个配置项参数<code>-l</code>、<code>-h</code>、<code>-a</code>，其中只有<code>-a</code>可以带有参数值，而<code>-l</code>和<code>-h</code>是开关参数，那么<code>getopts</code>的第一个参数写成<code>lha:</code>，顺序不重要。注意，<code>a</code>后面有一个冒号，表示该参数带有参数值，<code>getopts</code>规定带有参数值的配置项参数，后面必须带有一个冒号（<code>:</code>）。<code>getopts</code>的第二个参数<code>name</code>是一个变量名，用来保存当前取到的配置项参数，即<code>l</code>、<code>h</code>或<code>a</code>。</p>
<p>下面是一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> <span class="token string">'lha:'</span> OPTION<span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$OPTION</span>"</span> <span class="token keyword">in</span>
    l<span class="token punctuation">)</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"linuxconfig"</span>
      <span class="token punctuation">;</span><span class="token punctuation">;</span>

    h<span class="token punctuation">)</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"h stands for h"</span>
      <span class="token punctuation">;</span><span class="token punctuation">;</span>

    a<span class="token punctuation">)</span>
      <span class="token assign-left variable">avalue</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$OPTARG</span>"</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"The value provided is <span class="token variable">$OPTARG</span>"</span>
      <span class="token punctuation">;</span><span class="token punctuation">;</span>
    ?<span class="token punctuation">)</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"script usage: <span class="token variable"><span class="token variable">$(</span><span class="token function">basename</span> $0<span class="token variable">)</span></span> [-l] [-h] [-a somevalue]"</span> <span class="token operator">></span><span class="token file-descriptor important">&amp;2</span>
      <span class="token builtin class-name">exit</span> <span class="token number">1</span>
      <span class="token punctuation">;</span><span class="token punctuation">;</span>
  <span class="token keyword">esac</span>
<span class="token keyword">done</span>
<span class="token builtin class-name">shift</span> <span class="token string">"<span class="token variable"><span class="token variable">$((</span>$OPTIND <span class="token operator">-</span> <span class="token number">1</span><span class="token variable">))</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>while</code>循环不断执行<code>getopts &#39;lha:&#39; OPTION</code>命令，每次执行就会读取一个连词线参数（以及对应的参数值），然后进入循环体。变量<code>OPTION</code>保存的是，当前处理的那一个连词线参数（即<code>l</code>、<code>h</code>或<code>a</code>）。如果用户输入了没有指定的参数（比如<code>-x</code>），那么<code>OPTION</code>等于<code>?</code>。循环体内使用<code>case</code>判断，处理这四种不同的情况。</p>
<p>如果某个连词线参数带有参数值，比如<code>-a foo</code>，那么处理<code>a</code>参数的时候，环境变量<code>$OPTARG</code>保存的就是参数值。</p>
<p>注意，只要遇到不带连词线的参数，<code>getopts</code>就会执行失败，从而退出<code>while</code>循环。比如，<code>getopts</code>可以解析<code>command -l foo</code>，但不可以解析<code>command foo -l</code>。另外，多个连词线参数写在一起的形式，比如<code>command -lh</code>，<code>getopts</code>也可以正确处理。</p>
<p>变量<code>$OPTIND</code>在<code>getopts</code>开始执行前是<code>1</code>，然后每次执行就会加<code>1</code>。等到退出<code>while</code>循环，就意味着连词线参数全部处理完毕。这时，<code>$OPTIND - 1</code>就是已经处理的连词线参数个数，使用<code>shift</code>命令将这些参数移除，保证后面的代码可以用<code>$1</code>、<code>$2</code>等处理命令的主参数。</p>
<h2 id="配置项参数终止符"><a href="#配置项参数终止符" class="headerlink" title="配置项参数终止符 --"></a>配置项参数终止符 <code>--</code></h2><p><code>-</code>和<code>--</code>开头的参数，会被 Bash 当作配置项解释。但是，有时它们不是配置项，而是实体参数的一部分，比如文件名叫做<code>-f</code>或<code>--file</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> -f
$ <span class="token function">cat</span> --file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面命令的原意是输出文件<code>-f</code>和<code>--file</code>的内容，但是会被 Bash 当作配置项解释。</p>
<p>这时就可以使用配置项参数终止符<code>--</code>，它的作用是告诉 Bash，在它后面的参数开头的<code>-</code>和<code>--</code>不是配置项，只能当作实体参数解释。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> -- -f
$ <span class="token function">cat</span> -- --file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面命令可以正确展示文件<code>-f</code>和<code>--file</code>的内容，因为它们放在<code>--</code>的后面，开头的<code>-</code>和<code>--</code>就不再当作配置项解释了。</p>
<p>如果要确保某个变量不会被当作配置项解释，就要在它前面放上参数终止符<code>--</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> -- <span class="token variable">$myPath</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面示例中，<code>--</code>强制变量<code>$myPath</code>只能当作实体参数（即路径名）解释。如果变量不是路径名，就会报错。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">myPath</span><span class="token operator">=</span><span class="token string">"-l"</span>
$ <span class="token function">ls</span> -- <span class="token variable">$myPath</span>
ls: 无法访问<span class="token string">'-l'</span><span class="token builtin class-name">:</span> 没有那个文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，变量<code>myPath</code>的值为<code>-l</code>，不是路径。但是，<code>--</code>强制<code>$myPath</code>只能作为路径解释，导致报错“不存在该路径”。</p>
<p>下面是另一个实际的例子，如果想在文件里面搜索<code>--hello</code>，这时也要使用参数终止符<code>--</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">grep</span> -- <span class="token string">"--hello"</span> example.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令在<code>example.txt</code>文件里面，搜索字符串<code>--hello</code>。这个字符串是<code>--</code>开头，如果不用参数终止符，<code>grep</code>命令就会把<code>--hello</code>当作配置项参数，从而报错。</p>
<h2 id="exit-命令"><a href="#exit-命令" class="headerlink" title="exit 命令"></a>exit 命令</h2><p><code>exit</code>命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态。</p>
<p><code>exit</code>命令后面可以跟参数，该参数就是退出状态。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 退出值为0（成功）</span>
$ <span class="token builtin class-name">exit</span> <span class="token number">0</span>

<span class="token comment"># 退出值为1（失败）</span>
$ <span class="token builtin class-name">exit</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>退出时，脚本会返回一个退出值。脚本的退出值，<code>0</code>表示正常，<code>1</code>表示发生错误，<code>2</code>表示用法不对，<code>126</code>表示不是可执行脚本，<code>127</code>表示命令没有发现。如果脚本被信号<code>N</code>终止，则退出值为<code>128 + N</code>。简单来说，只要退出值非0，就认为执行出错。</p>
<p>下面是一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span> <span class="token operator">!=</span> <span class="token string">"0"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"根用户才能执行当前脚本"</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子中，<code>id -u</code>命令返回用户的 ID，一旦用户的 ID 不等于<code>0</code>（根用户的 ID），脚本就会退出，并且退出码为<code>1</code>，表示运行失败。</p>
<p><code>exit</code>与<code>return</code>命令的差别是，<code>return</code>命令是函数的退出，并返回一个值给调用者，脚本依然执行。<code>exit</code>是整个脚本的退出，如果在函数之中调用<code>exit</code>，则退出函数，并终止脚本执行。</p>
<h2 id="命令执行结果"><a href="#命令执行结果" class="headerlink" title="命令执行结果"></a>命令执行结果</h2><p>命令执行结束后，会有一个返回值。<code>0</code>表示执行成功，非<code>0</code>（通常是<code>1</code>）表示执行失败。环境变量<code>$?</code>可以读取前一个命令的返回值。</p>
<p>利用这一点，可以在脚本中对命令执行结果进行判断。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$some_directory</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$?</span>"</span> <span class="token operator">=</span> <span class="token string">"0"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token function">rm</span> *
<span class="token keyword">else</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"无法切换目录！"</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;2</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>cd $some_directory</code>这个命令如果执行成功（返回值等于<code>0</code>），就删除该目录里面的文件，否则退出脚本，整个脚本的返回值变为<code>1</code>，表示执行失败。</p>
<p>由于<code>if</code>可以直接判断命令的执行结果，执行相应的操作，上面的脚本可以改写成下面的样子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token builtin class-name">cd</span> <span class="token variable">$some_directory</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token function">rm</span> *
<span class="token keyword">else</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Could not change directory! Aborting."</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;2</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>更简洁的写法是利用两个逻辑运算符<code>&amp;&amp;</code>（且）和<code>||</code>（或）。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 第一步执行成功，才会执行第二步</span>
<span class="token builtin class-name">cd</span> <span class="token variable">$some_directory</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> *

<span class="token comment"># 第一步执行失败，才会执行第二步</span>
<span class="token builtin class-name">cd</span> <span class="token variable">$some_directory</span> <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="source-命令"><a href="#source-命令" class="headerlink" title="source 命令"></a>source 命令</h2><p><code>source</code>命令用于执行一个脚本，通常用于重新加载一个配置文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">source</span> .bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>source</code>命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，<code>source</code>命令执行脚本时，不需要<code>export</code>变量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># test.sh</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$foo</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面脚本输出<code>$foo</code>变量的值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 当前 Shell 新建一个变量 foo</span>
$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">1</span>

<span class="token comment"># 打印输出 1</span>
$ <span class="token builtin class-name">source</span> test.sh
<span class="token number">1</span>

<span class="token comment"># 打印输出空字符串</span>
$ <span class="token function">bash</span> test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，当前 Shell 的变量<code>foo</code>并没有<code>export</code>，所以直接执行无法读取，但是<code>source</code>执行可以读取。</p>
<p><code>source</code>命令的另一个用途，是在脚本内部加载外部库。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">source</span> ./lib.sh

function_from_lib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面脚本在内部使用<code>source</code>命令加载了一个外部库，然后就可以在脚本里面，使用这个外部库定义的函数。</p>
<p><code>source</code>有一个简写形式，可以使用一个点（<code>.</code>）来表示。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">.</span> .bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="别名，alias-命令"><a href="#别名，alias-命令" class="headerlink" title="别名，alias 命令"></a>别名，alias 命令</h2><p><code>alias</code>命令用来为一个命令指定别名，这样更便于记忆。下面是<code>alias</code>的格式。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">NAME</span><span class="token operator">=</span>DEFINITION<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令中，<code>NAME</code>是别名的名称，<code>DEFINITION</code>是别名对应的原始命令。注意，等号两侧不能有空格，否则会报错。</p>
<p>一个常见的例子是为<code>grep</code>命令起一个<code>search</code>的别名。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">search</span><span class="token operator">=</span>grep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>alias</code>也可以用来为长命令指定一个更短的别名。下面是通过别名定义一个<code>today</code>的命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">alias</span> <span class="token assign-left variable">today</span><span class="token operator">=</span><span class="token string">'date +"%A, %B %-d, %Y"'</span>
$ today
星期一, 一月 <span class="token number">6</span>, <span class="token number">2020</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>有时为了防止误删除文件，可以指定<code>rm</code>命令的别名。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">alias</span> <span class="token assign-left variable">rm</span><span class="token operator">=</span><span class="token string">'rm -i'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令指定<code>rm</code>命令是<code>rm -i</code>，每次删除文件之前，都会让用户确认。</p>
<p><code>alias</code>定义的别名也可以接受参数，参数会直接传入原始命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">alias</span> <span class="token assign-left variable">echo</span><span class="token operator">=</span><span class="token string">'echo It says: '</span>
$ <span class="token builtin class-name">echo</span> hello world
It says: hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，别名定义了<code>echo</code>命令的前两个参数，等同于修改了<code>echo</code>命令的默认行为。</p>
<p>指定别名以后，就可以像使用其他命令一样使用别名。一般来说，都会把常用的别名写在<code>~/.bashrc</code>的末尾。另外，只能为命令定义别名，为其他部分（比如很长的路径）定义别名是无效的。</p>
<p>直接调用<code>alias</code>命令，可以显示所有别名。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">alias</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>unalias</code>命令可以解除别名。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">unalias</span> lt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://linuxconfig.org/how-to-use-getopts-to-parse-a-script-options">How to use getopts to parse a script options</a>, Egidio Docile</li>
</ul>
<h1 id="read-命令"><a href="#read-命令" class="headerlink" title="read 命令"></a>read 命令</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>有时，脚本需要在执行过程中，由用户提供一部分数据，这时可以使用<code>read</code>命令。它将用户的输入存入一个变量，方便后面的代码使用。用户按下回车键，就表示输入结束。</p>
<p><code>read</code>命令的格式如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">read</span> <span class="token punctuation">[</span>-options<span class="token punctuation">]</span> <span class="token punctuation">[</span>variable<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面语法中，<code>options</code>是参数选项，<code>variable</code>是用来保存输入数值的一个或多个变量名。如果没有提供变量名，环境变量<code>REPLY</code>会包含用户输入的一整行数据。</p>
<p>下面是一个例子<code>demo.sh</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">echo</span> -n <span class="token string">"输入一些文本 > "</span>
<span class="token builtin class-name">read</span> text
<span class="token builtin class-name">echo</span> <span class="token string">"你的输入：<span class="token variable">$text</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，先显示一行提示文本，然后会等待用户输入文本。用户输入的文本，存入变量<code>text</code>，在下一行显示出来。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> demo.sh
输入一些文本 <span class="token operator">></span> 你好，世界
你的输入：你好，世界<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>read</code>可以接受用户输入的多个值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">echo</span> Please, enter your firstname and lastname
<span class="token builtin class-name">read</span> FN LN
<span class="token builtin class-name">echo</span> <span class="token string">"Hi! <span class="token variable">$LN</span>, <span class="token variable">$FN</span> !"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>read</code>根据用户的输入，同时为两个变量赋值。</p>
<p>如果用户的输入项少于<code>read</code>命令给出的变量数目，那么额外的变量值为空。如果用户的输入项多于定义的变量，那么多余的输入项会包含到最后一个变量中。</p>
<p>如果<code>read</code>命令之后没有定义变量名，那么环境变量<code>REPLY</code>会包含所有的输入。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># read-single: read multiple values into default variable</span>
<span class="token builtin class-name">echo</span> -n <span class="token string">"Enter one or more values > "</span>
<span class="token builtin class-name">read</span>
<span class="token builtin class-name">echo</span> <span class="token string">"REPLY = '<span class="token environment constant">$REPLY</span>'"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面脚本的运行结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ read-single
Enter one or <span class="token function">more</span> values <span class="token operator">></span> a b c d
<span class="token environment constant">REPLY</span> <span class="token operator">=</span> <span class="token string">'a b c d'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>read</code>命令除了读取键盘输入，可以用来读取文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">filename</span><span class="token operator">=</span><span class="token string">'/etc/hosts'</span>

<span class="token keyword">while</span> <span class="token builtin class-name">read</span> myline
<span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$myline</span>"</span>
<span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token variable">$filename</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子通过<code>read</code>命令，读取一个文件的内容。<code>done</code>命令后面的定向符<code>&lt;</code>，将文件内容导向<code>read</code>命令，每次读取一行，存入变量<code>myline</code>，直到文件读取完毕。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><code>read</code>命令的参数如下。</p>
<p><strong>（1）-t 参数</strong></p>
<p><code>read</code>命令的<code>-t</code>参数，设置了超时的秒数。如果超过了指定时间，用户仍然没有输入，脚本将放弃等待，继续向下执行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">echo</span> -n <span class="token string">"输入一些文本 > "</span>
<span class="token keyword">if</span> <span class="token builtin class-name">read</span> -t <span class="token number">3</span> response<span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"用户已经输入了"</span>
<span class="token keyword">else</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"用户没有输入"</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，输入命令会等待3秒，如果用户超过这个时间没有输入，这个命令就会执行失败。<code>if</code>根据命令的返回值，转入<code>else</code>代码块，继续往下执行。</p>
<p>环境变量<code>TMOUT</code>也可以起到同样作用，指定<code>read</code>命令等待用户输入的时间（单位为秒）。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">TMOUT</span><span class="token operator">=</span><span class="token number">3</span>
$ <span class="token builtin class-name">read</span> response<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子也是等待3秒，如果用户还没有输入，就会超时。</p>
<p><strong>（2）-p 参数</strong></p>
<p><code>-p</code>参数指定用户输入的提示信息。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">read</span> -p <span class="token string">"Enter one or more values > "</span>
<span class="token builtin class-name">echo</span> <span class="token string">"REPLY = '<span class="token environment constant">$REPLY</span>'"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，先显示<code>Enter one or more values &gt;</code>，再接受用户的输入。</p>
<p><strong>（3）-a 参数</strong></p>
<p><code>-a</code>参数把用户的输入赋值给一个数组，从零号位置开始。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">read</span> -a people
alice duchess dodo
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;people<span class="token punctuation">[</span>2<span class="token punctuation">]</span>&#125;</span>
dodo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，用户输入被赋值给一个数组<code>people</code>，这个数组的2号成员就是<code>dodo</code>。</p>
<p><strong>（4）-n 参数</strong></p>
<p><code>-n</code>参数指定只读取若干个字符作为变量值，而不是整行读取。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">read</span> -n <span class="token number">3</span> letter
abcdefghij
$ <span class="token builtin class-name">echo</span> <span class="token variable">$letter</span>
abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，变量<code>letter</code>只包含3个字母。</p>
<p><strong>（5）-e 参数</strong></p>
<p><code>-e</code>参数允许用户输入的时候，使用<code>readline</code>库提供的快捷键，比如自动补全。具体的快捷键可以参阅《行操作》一章。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">echo</span> Please input the path to the file:

<span class="token builtin class-name">read</span> -e fileName

<span class="token builtin class-name">echo</span> <span class="token variable">$fileName</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>read</code>命令接受用户输入的文件名。这时，用户可能想使用 Tab 键的文件名“自动补全”功能，但是<code>read</code>命令的输入默认不支持<code>readline</code>库的功能。<code>-e</code>参数就可以允许用户使用自动补全。</p>
<p><strong>（6）其他参数</strong></p>
<ul>
<li><code>-d delimiter</code>：定义字符串<code>delimiter</code>的第一个字符作为用户输入的结束，而不是一个换行符。</li>
<li><code>-r</code>：raw 模式，表示不把用户输入的反斜杠字符解释为转义字符。</li>
<li><code>-s</code>：使得用户的输入不显示在屏幕上，这常常用于输入密码或保密信息。</li>
<li><code>-u fd</code>：使用文件描述符<code>fd</code>作为输入。</li>
</ul>
<h2 id="IFS-变量"><a href="#IFS-变量" class="headerlink" title="IFS 变量"></a>IFS 变量</h2><p><code>read</code>命令读取的值，默认是以空格分隔。可以通过自定义环境变量<code>IFS</code>（内部字段分隔符，Internal Field Separator 的缩写），修改分隔标志。</p>
<p><code>IFS</code>的默认值是空格、Tab 符号、换行符号，通常取第一个（即空格）。</p>
<p>如果把<code>IFS</code>定义成冒号（<code>:</code>）或分号（<code>;</code>），就可以分隔以这两个符号分隔的值，这对读取文件很有用。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># read-ifs: read fields from a file</span>

<span class="token assign-left variable">FILE</span><span class="token operator">=</span>/etc/passwd

<span class="token builtin class-name">read</span> -p <span class="token string">"Enter a username > "</span> user_name
<span class="token assign-left variable">file_info</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">grep</span> <span class="token string">"^<span class="token variable">$user_name</span>:"</span> $FILE<span class="token variable">)</span></span>"</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$file_info</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">":"</span> <span class="token builtin class-name">read</span> user pw uid gid name home shell <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">"<span class="token variable">$file_info</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"User = '<span class="token variable">$user</span>'"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"UID = '<span class="token variable">$uid</span>'"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"GID = '<span class="token variable">$gid</span>'"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Full Name = '<span class="token variable">$name</span>'"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Home Dir. = '<span class="token variable">$home</span>'"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Shell = '<span class="token variable">$shell</span>'"</span>
<span class="token keyword">else</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"No such user '<span class="token variable">$user_name</span>'"</span> <span class="token operator">></span><span class="token file-descriptor important">&amp;2</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>IFS</code>设为冒号，然后用来分解<code>/etc/passwd</code>文件的一行。<code>IFS</code>的赋值命令和<code>read</code>命令写在一行，这样的话，<code>IFS</code>的改变仅对后面的命令生效，该命令执行后<code>IFS</code>会自动恢复原来的值。如果不写在一行，就要采用下面的写法。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">OLD_IFS</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$IFS</span>"</span>
<span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">":"</span>
<span class="token builtin class-name">read</span> user pw uid gid name home shell <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">"<span class="token variable">$file_info</span>"</span>
<span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">"<span class="token variable">$OLD_IFS</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>另外，上面例子中，<code>&lt;&lt;&lt;</code>是 Here 字符串，用于将变量值转为标准输入，因为<code>read</code>命令只能解析标准输入。</p>
<p>如果<code>IFS</code>设为空字符串，就等同于将整行读入一个变量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">input</span><span class="token operator">=</span><span class="token string">"/path/to/txt/file"</span>
<span class="token keyword">while</span> <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span> <span class="token builtin class-name">read</span> -r line
<span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$line</span>"</span>
<span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token string">"<span class="token variable">$input</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的命令可以逐行读取文件，每一行存入变量<code>line</code>，打印出来以后再读取下一行。</p>
<h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>本章介绍 Bash 脚本的条件判断语法。</p>
<h2 id="if-结构"><a href="#if-结构" class="headerlink" title="if 结构"></a>if 结构</h2><p><code>if</code>是最常用的条件判断结构，只有符合给定条件时，才会执行指定的命令。它的语法如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> commands<span class="token punctuation">;</span> <span class="token keyword">then</span>
  commands
<span class="token punctuation">[</span>elif commands<span class="token punctuation">;</span> <span class="token keyword">then</span>
  commands<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token punctuation">[</span>else
  commands<span class="token punctuation">]</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个命令分成三个部分：<code>if</code>、<code>elif</code>和<code>else</code>。其中，后两个部分是可选的。</p>
<p><code>if</code>关键字后面是主要的判断条件，<code>elif</code>用来添加在主条件不成立时的其他判断条件，<code>else</code>则是所有条件都不成立时要执行的部分。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token builtin class-name">test</span> <span class="token environment constant">$USER</span> <span class="token operator">=</span> <span class="token string">"foo"</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Hello foo."</span>
<span class="token keyword">else</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"You are not foo."</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子中，判断条件是环境变量<code>$USER</code>是否等于<code>foo</code>，如果等于就输出<code>Hello foo.</code>，否则输出其他内容。</p>
<p><code>if</code>和<code>then</code>写在同一行时，需要分号分隔。分号是 Bash 的命令分隔符。它们也可以写成两行，这时不需要分号。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token boolean">true</span>
<span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">'hello world'</span>
<span class="token keyword">fi</span>

<span class="token keyword">if</span> <span class="token boolean">false</span>
<span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">'it is false'</span> <span class="token comment"># 本行不会执行</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子中，<code>true</code>和<code>false</code>是两个特殊命令，前者代表操作成功，后者代表操作失败。<code>if true</code>意味着命令部分总是会执行，<code>if false</code>意味着命令部分永远不会执行。</p>
<p>除了多行的写法，<code>if</code>结构也可以写成单行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">'hello world'</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
hello world

$ <span class="token keyword">if</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"It's true."</span><span class="token punctuation">;</span> <span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，<code>if</code>关键字后面也可以是一条命令，该条命令执行成功（返回值<code>0</code>），就意味着判断条件成立。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token builtin class-name">echo</span> <span class="token string">'hi'</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">'hello world'</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
hi
hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面命令中，<code>if</code>后面是一条命令<code>echo &#39;hi&#39;</code>。该命令会执行，如果返回值是<code>0</code>，则执行<code>then</code>的部分。</p>
<p><code>if</code>后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回<code>0</code>，就会执行<code>then</code>的部分。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">'hello world'</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，<code>if</code>后面有两条命令（<code>false;true;</code>），第二条命令（<code>true</code>）决定了<code>then</code>的部分是否会执行。</p>
<p><code>elif</code>部分可以有多个。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">echo</span> -n <span class="token string">"输入一个1到3之间的数字（包含两端）> "</span>
<span class="token builtin class-name">read</span> character
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$character</span>"</span> <span class="token operator">=</span> <span class="token string">"1"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token number">1</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$character</span>"</span> <span class="token operator">=</span> <span class="token string">"2"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token number">2</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$character</span>"</span> <span class="token operator">=</span> <span class="token string">"3"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token number">3</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> 输入不符合要求
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，如果用户输入<code>3</code>，就会连续判断3次。</p>
<h2 id="test-命令"><a href="#test-命令" class="headerlink" title="test 命令"></a>test 命令</h2><p><code>if</code>结构的判断条件，一般使用<code>test</code>命令，有三种形式。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 写法一</span>
<span class="token builtin class-name">test</span> expression

<span class="token comment"># 写法二</span>
<span class="token punctuation">[</span> expression <span class="token punctuation">]</span>

<span class="token comment"># 写法三</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> expression <span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。</p>
<p>上面的<code>expression</code>是一个表达式。这个表达式为真，<code>test</code>命令执行成功（返回值为<code>0</code>）；表达式为伪，<code>test</code>命令执行失败（返回值为<code>1</code>）。注意，第二种和第三种写法，<code>[</code>和<code>]</code>与内部的表达式之间必须有空格。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">test</span> -f /etc/hosts
$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">0</span>

$ <span class="token punctuation">[</span> -f /etc/hosts <span class="token punctuation">]</span>
$  <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子中，<code>test</code>命令采用两种写法，判断<code>/etc/hosts</code>文件是否存在，这两种写法是等价的。命令执行后，返回值为<code>0</code>，表示该文件确实存在。</p>
<p>实际上，<code>[</code>这个字符是<code>test</code>命令的一种简写形式，可以看作是一个独立的命令，这解释了为什么它后面必须有空格。</p>
<p>下面把<code>test</code>命令的三种形式，用在<code>if</code>结构中，判断一个文件是否存在。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 写法一</span>
<span class="token keyword">if</span> <span class="token builtin class-name">test</span> -e /tmp/foo.txt <span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Found foo.txt"</span>
<span class="token keyword">fi</span>

<span class="token comment"># 写法二</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> -e /tmp/foo.txt <span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Found foo.txt"</span>
<span class="token keyword">fi</span>

<span class="token comment"># 写法三</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> -e /tmp/foo.txt <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Found foo.txt"</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="判断表达式"><a href="#判断表达式" class="headerlink" title="判断表达式"></a>判断表达式</h2><p><code>if</code>关键字后面，跟的是一个命令。这个命令可以是<code>test</code>命令，也可以是其他命令。命令的返回值为<code>0</code>表示判断成立，否则表示不成立。因为这些命令主要是为了得到返回值，所以可以视为表达式。</p>
<p>常用的判断表达式有下面这些。</p>
<h3 id="文件判断"><a href="#文件判断" class="headerlink" title="文件判断"></a>文件判断</h3><p>以下表达式用来判断文件状态。</p>
<ul>
<li><code>[ -a file ]</code>：如果 file 存在，则为<code>true</code>。</li>
<li><code>[ -b file ]</code>：如果 file 存在并且是一个块（设备）文件，则为<code>true</code>。</li>
<li><code>[ -c file ]</code>：如果 file 存在并且是一个字符（设备）文件，则为<code>true</code>。</li>
<li><code>[ -d file ]</code>：如果 file 存在并且是一个目录，则为<code>true</code>。</li>
<li><code>[ -e file ]</code>：如果 file 存在，则为<code>true</code>。</li>
<li><code>[ -f file ]</code>：如果 file 存在并且是一个普通文件，则为<code>true</code>。</li>
<li><code>[ -g file ]</code>：如果 file 存在并且设置了组 ID，则为<code>true</code>。</li>
<li><code>[ -G file ]</code>：如果 file 存在并且属于有效的组 ID，则为<code>true</code>。</li>
<li><code>[ -h file ]</code>：如果 file 存在并且是符号链接，则为<code>true</code>。</li>
<li><code>[ -k file ]</code>：如果 file 存在并且设置了它的“sticky bit”，则为<code>true</code>。</li>
<li><code>[ -L file ]</code>：如果 file 存在并且是一个符号链接，则为<code>true</code>。</li>
<li><code>[ -N file ]</code>：如果 file 存在并且自上次读取后已被修改，则为<code>true</code>。</li>
<li><code>[ -O file ]</code>：如果 file 存在并且属于有效的用户 ID，则为<code>true</code>。</li>
<li><code>[ -p file ]</code>：如果 file 存在并且是一个命名管道，则为<code>true</code>。</li>
<li><code>[ -r file ]</code>：如果 file 存在并且可读（当前用户有可读权限），则为<code>true</code>。</li>
<li><code>[ -s file ]</code>：如果 file 存在且其长度大于零，则为<code>true</code>。</li>
<li><code>[ -S file ]</code>：如果 file 存在且是一个网络 socket，则为<code>true</code>。</li>
<li><code>[ -t fd ]</code>：如果 fd 是一个文件描述符，并且重定向到终端，则为<code>true</code>。 这可以用来判断是否重定向了标准输入／输出／错误。</li>
<li><code>[ -u file ]</code>：如果 file 存在并且设置了 setuid 位，则为<code>true</code>。</li>
<li><code>[ -w file ]</code>：如果 file 存在并且可写（当前用户拥有可写权限），则为<code>true</code>。</li>
<li><code>[ -x file ]</code>：如果 file 存在并且可执行（有效用户有执行／搜索权限），则为<code>true</code>。</li>
<li><code>[ file1 -nt file2 ]</code>：如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为<code>true</code>。</li>
<li><code>[ file1 -ot file2 ]</code>：如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为<code>true</code>。</li>
<li><code>[ FILE1 -ef FILE2 ]</code>：如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为<code>true</code>。</li>
</ul>
<p>下面是一个示例。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">FILE</span><span class="token operator">=</span>~/.bashrc

<span class="token keyword">if</span> <span class="token punctuation">[</span> -e <span class="token string">"<span class="token variable">$FILE</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span> -f <span class="token string">"<span class="token variable">$FILE</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$FILE</span> is a regular file."</span>
  <span class="token keyword">fi</span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span> -d <span class="token string">"<span class="token variable">$FILE</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$FILE</span> is a directory."</span>
  <span class="token keyword">fi</span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span> -r <span class="token string">"<span class="token variable">$FILE</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$FILE</span> is readable."</span>
  <span class="token keyword">fi</span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span> -w <span class="token string">"<span class="token variable">$FILE</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$FILE</span> is writable."</span>
  <span class="token keyword">fi</span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span> -x <span class="token string">"<span class="token variable">$FILE</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$FILE</span> is executable/searchable."</span>
  <span class="token keyword">fi</span>
<span class="token keyword">else</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$FILE</span> does not exist"</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>$FILE</code>要放在双引号之中。这样可以防止<code>$FILE</code>为空，因为这时<code>[ -e ]</code>会判断为真。而放在双引号之中，返回的就总是一个空字符串，<code>[ -e &quot;&quot; ]</code>会判断为伪。</p>
<h3 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h3><p>以下表达式用来判断字符串。</p>
<ul>
<li><code>[ string ]</code>：如果<code>string</code>不为空（长度大于0），则判断为真。</li>
<li><code>[ -n string ]</code>：如果字符串<code>string</code>的长度大于零，则判断为真。</li>
<li><code>[ -z string ]</code>：如果字符串<code>string</code>的长度为零，则判断为真。</li>
<li><code>[ string1 = string2 ]</code>：如果<code>string1</code>和<code>string2</code>相同，则判断为真。</li>
<li><code>[ string1 == string2 ]</code> 等同于<code>[ string1 = string2 ]</code>。</li>
<li><code>[ string1 != string2 ]</code>：如果<code>string1</code>和<code>string2</code>不相同，则判断为真。</li>
<li><code>[ string1 &#39;&gt;&#39; string2 ]</code>：如果按照字典顺序<code>string1</code>排列在<code>string2</code>之后，则判断为真。</li>
<li><code>[ string1 &#39;&lt;&#39; string2 ]</code>：如果按照字典顺序<code>string1</code>排列在<code>string2</code>之前，则判断为真。</li>
</ul>
<p>注意，<code>test</code>命令内部的<code>&gt;</code>和<code>&lt;</code>，必须用引号引起来（或者是用反斜杠转义）。否则，它们会被 shell 解释为重定向操作符。</p>
<p>下面是一个示例。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">ANSWER</span><span class="token operator">=</span>maybe

<span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$ANSWER</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"There is no answer."</span> <span class="token operator">></span><span class="token file-descriptor important">&amp;2</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$ANSWER</span>"</span> <span class="token operator">=</span> <span class="token string">"yes"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"The answer is YES."</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$ANSWER</span>"</span> <span class="token operator">=</span> <span class="token string">"no"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"The answer is NO."</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$ANSWER</span>"</span> <span class="token operator">=</span> <span class="token string">"maybe"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"The answer is MAYBE."</span>
<span class="token keyword">else</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"The answer is UNKNOWN."</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，首先确定<code>$ANSWER</code>字符串是否为空。如果为空，就终止脚本，并把退出状态设为<code>1</code>。注意，这里的<code>echo</code>命令把错误信息<code>There is no answer.</code>重定向到标准错误，这是处理错误信息的常用方法。如果<code>$ANSWER</code>字符串不为空，就判断它的值是否等于<code>yes</code>、<code>no</code>或者<code>maybe</code>。</p>
<p>注意，字符串判断时，变量要放在双引号之中，比如<code>[ -n &quot;$COUNT&quot; ]</code>，否则变量替换成字符串以后，<code>test</code>命令可能会报错，提示参数过多。另外，如果不放在双引号之中，变量为空时，命令会变成<code>[ -n ]</code>，这时会判断为真。如果放在双引号之中，<code>[ -n &quot;&quot; ]</code>就判断为伪。</p>
<h3 id="整数判断"><a href="#整数判断" class="headerlink" title="整数判断"></a>整数判断</h3><p>下面的表达式用于判断整数。</p>
<ul>
<li><code>[ integer1 -eq integer2 ]</code>：如果<code>integer1</code>等于<code>integer2</code>，则为<code>true</code>。</li>
<li><code>[ integer1 -ne integer2 ]</code>：如果<code>integer1</code>不等于<code>integer2</code>，则为<code>true</code>。</li>
<li><code>[ integer1 -le integer2 ]</code>：如果<code>integer1</code>小于或等于<code>integer2</code>，则为<code>true</code>。</li>
<li><code>[ integer1 -lt integer2 ]</code>：如果<code>integer1</code>小于<code>integer2</code>，则为<code>true</code>。</li>
<li><code>[ integer1 -ge integer2 ]</code>：如果<code>integer1</code>大于或等于<code>integer2</code>，则为<code>true</code>。</li>
<li><code>[ integer1 -gt integer2 ]</code>：如果<code>integer1</code>大于<code>integer2</code>，则为<code>true</code>。</li>
</ul>
<p>下面是一个用法的例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">INT</span><span class="token operator">=</span>-5

<span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$INT</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"INT is empty."</span> <span class="token operator">></span><span class="token file-descriptor important">&amp;2</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$INT</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"INT is zero."</span>
<span class="token keyword">else</span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$INT</span> -lt <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"INT is negative."</span>
  <span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"INT is positive."</span>
  <span class="token keyword">fi</span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable"><span class="token variable">$((</span>INT <span class="token operator">%</span> <span class="token number">2</span><span class="token variable">))</span></span> -eq <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"INT is even."</span>
  <span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"INT is odd."</span>
  <span class="token keyword">fi</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，先判断变量<code>$INT</code>是否为空，然后判断是否为<code>0</code>，接着判断正负，最后通过求余数判断奇偶。</p>
<h3 id="正则判断"><a href="#正则判断" class="headerlink" title="正则判断"></a>正则判断</h3><p><code>[[ expression ]]</code>这种判断形式，支持正则表达式。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token punctuation">[</span> string1 <span class="token operator">=</span>~ regex <span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的语法中，<code>regex</code>是一个正则表示式，<code>=~</code>是正则比较运算符。</p>
<p>下面是一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">INT</span><span class="token operator">=</span>-5

<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$INT</span>"</span> <span class="token operator">=</span>~ ^-?<span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+$ <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"INT is an integer."</span>
  <span class="token builtin class-name">exit</span> <span class="token number">0</span>
<span class="token keyword">else</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"INT is not an integer."</span> <span class="token operator">></span><span class="token file-descriptor important">&amp;2</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，先判断变量<code>INT</code>的字符串形式，是否满足<code>^-?[0-9]+$</code>的正则模式，如果满足就表明它是一个整数。</p>
<h3 id="test-判断的逻辑运算"><a href="#test-判断的逻辑运算" class="headerlink" title="test 判断的逻辑运算"></a>test 判断的逻辑运算</h3><p>通过逻辑运算，可以把多个<code>test</code>判断表达式结合起来，创造更复杂的判断。三种逻辑运算<code>AND</code>，<code>OR</code>，和<code>NOT</code>，都有自己的专用符号。</p>
<ul>
<li><code>AND</code>运算：符号<code>&amp;&amp;</code>，也可使用参数<code>-a</code>。</li>
<li><code>OR</code>运算：符号<code>||</code>，也可使用参数<code>-o</code>。</li>
<li><code>NOT</code>运算：符号<code>!</code>。</li>
</ul>
<p>下面是一个<code>AND</code>的例子，判断整数是否在某个范围之内。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">MIN_VAL</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token assign-left variable">MAX_VAL</span><span class="token operator">=</span><span class="token number">100</span>

<span class="token assign-left variable">INT</span><span class="token operator">=</span><span class="token number">50</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$INT</span>"</span> <span class="token operator">=</span>~ ^-?<span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+$ <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$INT</span> -ge <span class="token variable">$MIN_VAL</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$INT</span> -le <span class="token variable">$MAX_VAL</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$INT</span> is within <span class="token variable">$MIN_VAL</span> to <span class="token variable">$MAX_VAL</span>."</span>
  <span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$INT</span> is out of range."</span>
  <span class="token keyword">fi</span>
<span class="token keyword">else</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"INT is not an integer."</span> <span class="token operator">></span><span class="token file-descriptor important">&amp;2</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>&amp;&amp;</code>用来连接两个判断条件：大于等于<code>$MIN_VAL</code>，并且小于等于<code>$MAX_VAL</code>。</p>
<p>使用否定操作符<code>!</code>时，最好用圆括号确定转义的范围。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token punctuation">\</span><span class="token punctuation">(</span> <span class="token variable">$INT</span> -ge <span class="token variable">$MIN_VAL</span> -a <span class="token variable">$INT</span> -le <span class="token variable">$MAX_VAL</span> <span class="token punctuation">\</span><span class="token punctuation">)</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$INT</span> is outside <span class="token variable">$MIN_VAL</span> to <span class="token variable">$MAX_VAL</span>."</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$INT</span> is in range."</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>test</code>命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</p>
<h3 id="算术判断"><a href="#算术判断" class="headerlink" title="算术判断"></a>算术判断</h3><p>Bash 还提供了<code>((...))</code>作为算术条件，进行算术运算的判断。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span><span class="token number">3</span> <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"true"</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面代码执行后，会打印出<code>true</code>。</p>
<p>注意，算术判断不需要使用<code>test</code>命令，而是直接使用<code>((...))</code>结构。这个结构的返回值，决定了判断的真伪。</p>
<p>如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span><span class="token number">1</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"It is true."</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
It is true.
$ <span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span><span class="token number">0</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"It is true."</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token builtin class-name">echo</span> <span class="token string">"it is false."</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
It is false.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>((1))</code>表示判断成立，<code>((0))</code>表示判断不成立。</p>
<p>算术条件<code>((...))</code>也可以用于变量赋值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span> foo <span class="token operator">=</span> <span class="token number">5</span> <span class="token punctuation">))</span></span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"foo is <span class="token variable">$foo</span>"</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
foo is <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子中，<code>(( foo = 5 ))</code>完成了两件事情。首先把<code>5</code>赋值给变量<code>foo</code>，然后根据返回值<code>5</code>，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是<code>0</code>，则判断为假。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span> foo <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">))</span></span><span class="token punctuation">;</span><span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"It is true."</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token builtin class-name">echo</span> <span class="token string">"It is false."</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
It is false.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>下面是用算术条件改写的数值判断脚本。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">INT</span><span class="token operator">=</span>-5

<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$INT</span>"</span> <span class="token operator">=</span>~ ^-?<span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+$ <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span>INT <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"INT is zero."</span>
  <span class="token keyword">else</span>
    <span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span>INT <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">then</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"INT is negative."</span>
    <span class="token keyword">else</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"INT is positive."</span>
    <span class="token keyword">fi</span>
    <span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span> <span class="token punctuation">((</span>INT <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">))</span></span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">))</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"INT is even."</span>
    <span class="token keyword">else</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"INT is odd."</span>
    <span class="token keyword">fi</span>
  <span class="token keyword">fi</span>
<span class="token keyword">else</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"INT is not an integer."</span> <span class="token operator">></span><span class="token file-descriptor important">&amp;2</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>只要是算术表达式，都能用于<code>((...))</code>语法，详见《Bash 的算术运算》一章。</p>
<h3 id="普通命令的逻辑运算"><a href="#普通命令的逻辑运算" class="headerlink" title="普通命令的逻辑运算"></a>普通命令的逻辑运算</h3><p>如果<code>if</code>结构使用的不是<code>test</code>命令，而是普通命令，比如上一节的<code>((...))</code>算术运算，或者<code>test</code>命令与普通命令混用，那么可以使用 Bash 的命令控制操作符<code>&amp;&amp;</code>（AND）和<code>||</code>（OR），进行多个命令的逻辑运算。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ command1 <span class="token operator">&amp;&amp;</span> command2
$ command1 <span class="token operator">||</span> command2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>对于<code>&amp;&amp;</code>操作符，先执行<code>command1</code>，只有<code>command1</code>执行成功后， 才会执行<code>command2</code>。对于<code>||</code>操作符，先执行<code>command1</code>，只有<code>command1</code>执行失败后， 才会执行<code>command2</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> temp <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> temp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的命令会创建一个名为<code>temp</code>的目录，执行成功后，才会执行第二个命令，进入这个目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token punctuation">[</span> -d temp <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token function">mkdir</span> temp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的命令会测试目录<code>temp</code>是否存在，如果不存在，就会执行第二个命令，创建这个目录。这种写法非常有助于在脚本中处理错误。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span> <span class="token operator">!</span> -d temp <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的命令中，如果<code>temp</code>子目录不存在，脚本会终止，并且返回值为<code>1</code>。</p>
<p>下面就是<code>if</code>与<code>&amp;&amp;</code>结合使用的写法。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> condition <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> condition <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">command</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>下面是一个示例。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#! /bin/bash</span>

<span class="token assign-left variable">filename</span><span class="token operator">=</span><span class="token variable">$1</span>
<span class="token assign-left variable">word1</span><span class="token operator">=</span><span class="token variable">$2</span>
<span class="token assign-left variable">word2</span><span class="token operator">=</span><span class="token variable">$3</span>

<span class="token keyword">if</span> <span class="token function">grep</span> <span class="token variable">$word1</span> <span class="token variable">$filename</span> <span class="token operator">&amp;&amp;</span> <span class="token function">grep</span> <span class="token variable">$word2</span> <span class="token variable">$filename</span>
<span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$word1</span> and <span class="token variable">$word2</span> are both in <span class="token variable">$filename</span>."</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子只有在指定文件里面，同时存在搜索词<code>word1</code>和<code>word2</code>，就会执行<code>if</code>的命令部分。</p>
<p>下面的示例演示如何将一个<code>&amp;&amp;</code>判断表达式，改写成对应的<code>if</code>结构。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token punctuation">[</span> -d <span class="token string">"<span class="token variable">$dir_name</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> <span class="token string">"<span class="token variable">$dir_name</span>"</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> *

<span class="token comment"># 等同于</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">!</span> -d <span class="token string">"<span class="token variable">$dir_name</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"No such directory: '<span class="token variable">$dir_name</span>'"</span> <span class="token operator">></span><span class="token file-descriptor important">&amp;2</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span>
<span class="token keyword">if</span> <span class="token operator">!</span> <span class="token builtin class-name">cd</span> <span class="token string">"<span class="token variable">$dir_name</span>"</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Cannot cd to '<span class="token variable">$dir_name</span>'"</span> <span class="token operator">></span><span class="token file-descriptor important">&amp;2</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span>
<span class="token keyword">if</span> <span class="token operator">!</span> <span class="token function">rm</span> *<span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"File deletion failed. Check results"</span> <span class="token operator">></span><span class="token file-descriptor important">&amp;2</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="case-结构"><a href="#case-结构" class="headerlink" title="case 结构"></a>case 结构</h2><p><code>case</code>结构用于多值判断，可以为每个值指定对应的命令，跟包含多个<code>elif</code>的<code>if</code>结构等价，但是语义更好。它的语法如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">case</span> expression <span class="token keyword">in</span>
  pattern <span class="token punctuation">)</span>
    commands <span class="token punctuation">;</span><span class="token punctuation">;</span>
  pattern <span class="token punctuation">)</span>
    commands <span class="token punctuation">;</span><span class="token punctuation">;</span>
  <span class="token punctuation">..</span>.
<span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>expression</code>是一个表达式，<code>pattern</code>是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号（<code>;</code>）结尾。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">echo</span> -n <span class="token string">"输入一个1到3之间的数字（包含两端）> "</span>
<span class="token builtin class-name">read</span> character
<span class="token keyword">case</span> <span class="token variable">$character</span> <span class="token keyword">in</span>
  <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token number">1</span>
    <span class="token punctuation">;</span><span class="token punctuation">;</span>
  <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token number">2</span>
    <span class="token punctuation">;</span><span class="token punctuation">;</span>
  <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token number">3</span>
    <span class="token punctuation">;</span><span class="token punctuation">;</span>
  * <span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> 输入不符合要求
<span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，最后一条匹配语句的模式是<code>*</code>，这个通配符可以匹配其他字符和没有输入字符的情况，类似<code>if</code>的<code>else</code>部分。</p>
<p>下面是另一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">OS</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">uname</span> -s<span class="token variable">)</span></span>

<span class="token keyword">case</span> <span class="token string">"<span class="token variable">$OS</span>"</span> <span class="token keyword">in</span>
  FreeBSD<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"This is FreeBSD"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>
  Darwin<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"This is Mac OSX"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>
  AIX<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"This is AIX"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>
  Minix<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"This is Minix"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>
  Linux<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"This is Linux"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>
  *<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"Failed to identify this OS"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子判断当前是什么操作系统。</p>
<p><code>case</code>的匹配模式可以使用各种通配符，下面是一些例子。</p>
<ul>
<li><code>a)</code>：匹配<code>a</code>。</li>
<li><code>a|b)</code>：匹配<code>a</code>或<code>b</code>。</li>
<li><code>[[:alpha:]])</code>：匹配单个字母。</li>
<li><code>???)</code>：匹配3个字符的单词。</li>
<li><code>*.txt)</code>：匹配<code>.txt</code>结尾。</li>
<li><code>*)</code>：匹配任意输入，通过作为<code>case</code>结构的最后一个模式。</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">echo</span> -n <span class="token string">"输入一个字母或数字 > "</span>
<span class="token builtin class-name">read</span> character
<span class="token keyword">case</span> <span class="token variable">$character</span> <span class="token keyword">in</span>
  <span class="token punctuation">[</span><span class="token punctuation">[</span>:lower:<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>:upper:<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"输入了字母 <span class="token variable">$character</span>"</span>
                              <span class="token punctuation">;</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span> <span class="token punctuation">)</span>                     <span class="token builtin class-name">echo</span> <span class="token string">"输入了数字 <span class="token variable">$character</span>"</span>
                              <span class="token punctuation">;</span><span class="token punctuation">;</span>
  * <span class="token punctuation">)</span>                         <span class="token builtin class-name">echo</span> <span class="token string">"输入不符合要求"</span>
<span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，使用通配符<code>[[:lower:]] | [[:upper:]]</code>匹配字母，<code>[0-9]</code>匹配数字。</p>
<p>Bash 4.0之前，<code>case</code>结构只能匹配一个条件，然后就会退出<code>case</code>结构。Bash 4.0之后，允许匹配多个条件，这时可以用<code>;;&amp;</code>终止每个条件块。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># test.sh</span>

<span class="token builtin class-name">read</span> -n <span class="token number">1</span> -p <span class="token string">"Type a character > "</span>
<span class="token builtin class-name">echo</span>
<span class="token keyword">case</span> <span class="token environment constant">$REPLY</span> <span class="token keyword">in</span>
  <span class="token punctuation">[</span><span class="token punctuation">[</span>:upper:<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token builtin class-name">echo</span> <span class="token string">"'<span class="token environment constant">$REPLY</span>' is upper case."</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>
  <span class="token punctuation">[</span><span class="token punctuation">[</span>:lower:<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token builtin class-name">echo</span> <span class="token string">"'<span class="token environment constant">$REPLY</span>' is lower case."</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>
  <span class="token punctuation">[</span><span class="token punctuation">[</span>:alpha:<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token builtin class-name">echo</span> <span class="token string">"'<span class="token environment constant">$REPLY</span>' is alphabetic."</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>
  <span class="token punctuation">[</span><span class="token punctuation">[</span>:digit:<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token builtin class-name">echo</span> <span class="token string">"'<span class="token environment constant">$REPLY</span>' is a digit."</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>
  <span class="token punctuation">[</span><span class="token punctuation">[</span>:graph:<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token builtin class-name">echo</span> <span class="token string">"'<span class="token environment constant">$REPLY</span>' is a visible character."</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>
  <span class="token punctuation">[</span><span class="token punctuation">[</span>:punct:<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token builtin class-name">echo</span> <span class="token string">"'<span class="token environment constant">$REPLY</span>' is a punctuation symbol."</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>
  <span class="token punctuation">[</span><span class="token punctuation">[</span>:space:<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token builtin class-name">echo</span> <span class="token string">"'<span class="token environment constant">$REPLY</span>' is a whitespace character."</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>
  <span class="token punctuation">[</span><span class="token punctuation">[</span>:xdigit:<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token builtin class-name">echo</span> <span class="token string">"'<span class="token environment constant">$REPLY</span>' is a hexadecimal digit."</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>
<span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行上面的脚本，会得到下面的结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ test.sh
Type a character <span class="token operator">></span> a
<span class="token string">'a'</span> is lower case.
<span class="token string">'a'</span> is alphabetic.
<span class="token string">'a'</span> is a visible character.
<span class="token string">'a'</span> is a hexadecimal digit.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到条件语句结尾添加了<code>;;&amp;</code>以后，在匹配一个条件之后，并没有退出<code>case</code>结构，而是继续判断下一个条件。</p>
<h2 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="http://linuxcommand.org/tlcl.php">The Linux Command Line</a>, William Shotts</li>
</ul>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>Bash 提供三种循环语法<code>for</code>、<code>while</code>和<code>until</code>。</p>
<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p><code>while</code>循环有一个判断条件，只要符合条件，就不断循环执行指定的语句。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">while</span> condition<span class="token punctuation">;</span> <span class="token keyword">do</span>
  commands
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，只要满足条件<code>condition</code>，就会执行命令<code>commands</code>。然后，再次判断是否满足条件<code>condition</code>，只要满足，就会一直执行下去。只有不满足条件，才会退出循环。</p>
<p>循环条件<code>condition</code>可以使用<code>test</code>命令，跟<code>if</code>结构的判断条件写法一致。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$number</span>"</span> -lt <span class="token number">10</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Number = <span class="token variable">$number</span>"</span>
  <span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>number <span class="token operator">+</span> <span class="token number">1</span><span class="token variable">))</span></span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，只要变量<code>$number</code>小于10，就会不断加1，直到<code>$number</code>等于10，然后退出循环。</p>
<p>关键字<code>do</code>可以跟<code>while</code>不在同一行，这时两者之间不需要使用分号分隔。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token boolean">true</span>
<span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">'Hi, while looping ...'</span><span class="token punctuation">;</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子会无限循环，可以按下 Ctrl + c 停止。</p>
<p><code>while</code>循环写成一行，也是可以的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token string">'Hi, while looping ...'</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>while</code>的条件部分也可以是执行一个命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">while</span> <span class="token builtin class-name">echo</span> <span class="token string">'ECHO'</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token string">'Hi, while looping ...'</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，判断条件是<code>echo &#39;ECHO&#39;</code>。由于这个命令总是执行成功，所以上面命令会产生无限循环。</p>
<p><code>while</code>的条件部分可以执行任意数量的命令，但是执行结果的真伪只看最后一个命令的执行结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token string">'Hi, looping ...'</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面代码运行后，不会有任何输出，因为<code>while</code>的最后一个命令是<code>false</code>。</p>
<h2 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h2><p><code>until</code>循环与<code>while</code>循环恰好相反，只要不符合判断条件（判断条件失败），就不断循环执行指定的语句。一旦符合判断条件，就退出循环。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">until</span> condition<span class="token punctuation">;</span> <span class="token keyword">do</span>
  commands
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>关键字<code>do</code>可以与<code>until</code>不写在同一行，这时两者之间不需要分号分隔。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">until</span> condition
<span class="token keyword">do</span>
  commands
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面是一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">until</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token builtin class-name">echo</span> <span class="token string">'Hi, until looping ...'</span><span class="token punctuation">;</span> <span class="token keyword">done</span>
Hi, <span class="token keyword">until</span> looping <span class="token punctuation">..</span>.
Hi, <span class="token keyword">until</span> looping <span class="token punctuation">..</span>.
Hi, <span class="token keyword">until</span> looping <span class="token punctuation">..</span>.
^C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>until</code>的部分一直为<code>false</code>，导致命令无限运行，必须按下 Ctrl + c 终止。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">until</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$number</span>"</span> -ge <span class="token number">10</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Number = <span class="token variable">$number</span>"</span>
  <span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>number <span class="token operator">+</span> <span class="token number">1</span><span class="token variable">))</span></span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，只要变量<code>number</code>小于10，就会不断加1，直到<code>number</code>大于等于10，就退出循环。</p>
<p><code>until</code>的条件部分也可以是一个命令，表示在这个命令执行成功之前，不断重复尝试。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">until</span> <span class="token function">cp</span> <span class="token variable">$1</span> <span class="token variable">$2</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">'Attempt to copy failed. waiting...'</span>
  <span class="token function">sleep</span> <span class="token number">5</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子表示，只要<code>cp $1 $2</code>这个命令执行不成功，就5秒钟后再尝试一次，直到成功为止。</p>
<p><code>until</code>循环都可以转为<code>while</code>循环，只要把条件设为否定即可。上面这个例子可以改写如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token operator">!</span> <span class="token function">cp</span> <span class="token variable">$1</span> <span class="token variable">$2</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">'Attempt to copy failed. waiting...'</span>
  <span class="token function">sleep</span> <span class="token number">5</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>一般来说，<code>until</code>用得比较少，完全可以统一都使用<code>while</code>。</p>
<h2 id="for…in-循环"><a href="#for…in-循环" class="headerlink" title="for…in 循环"></a>for…in 循环</h2><p><code>for...in</code>循环用于遍历列表的每一项。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">variable</span> <span class="token keyword">in</span> list
<span class="token keyword">do</span>
  commands
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面语法中，<code>for</code>循环会依次从<code>list</code>列表中取出一项，作为变量<code>variable</code>，然后在循环体中进行处理。</p>
<p>关键词<code>do</code>可以跟<code>for</code>写在同一行，两者使用分号分隔。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">variable</span> <span class="token keyword">in</span> list<span class="token punctuation">;</span> <span class="token keyword">do</span>
  commands
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>下面是一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> word1 word2 word3<span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token variable">$i</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>word1 word2 word3</code>是一个包含三个单词的列表，变量<code>i</code>依次等于<code>word1</code>、<code>word2</code>、<code>word3</code>，命令<code>echo $i</code>则会相应地执行三次。</p>
<p>列表可以由通配符产生。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> *.png<span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token function">ls</span> -l <span class="token variable">$i</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>*.png</code>会替换成当前目录中所有 PNG 图片文件，变量<code>i</code>会依次等于每一个文件。</p>
<p>列表也可以通过子命令产生。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> ~/.bash_profile<span class="token variable">)</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token variable">))</span></span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Word <span class="token variable">$count</span> (<span class="token variable">$i</span>) contains <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> -n $i <span class="token operator">|</span> <span class="token function">wc</span> -c<span class="token variable">)</span></span> characters"</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>cat ~/.bash_profile</code>命令会输出<code>~/.bash_profile</code>文件的内容，然后通过遍历每一个词，计算该文件一共包含多少个词，以及每个词有多少个字符。</p>
<p><code>in list</code>的部分可以省略，这时<code>list</code>默认等于脚本的所有参数<code>$@</code>。但是，为了可读性，最好还是不要省略，参考下面的例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> filename<span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$filename</span>"</span>
<span class="token keyword">done</span>

<span class="token comment"># 等同于</span>

<span class="token keyword">for</span> <span class="token for-or-select variable">filename</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$@</span>"</span> <span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$filename</span>"</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在函数体中也是一样的，<code>for...in</code>循环省略<code>in list</code>的部分，则<code>list</code>默认等于函数的所有参数。</p>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p><code>for</code>循环还支持 C 语言的循环语法。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> expression1<span class="token punctuation">;</span> expression2<span class="token punctuation">;</span> expression3 <span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  commands
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>expression1</code>用来初始化循环条件，<code>expression2</code>用来决定循环结束的条件，<code>expression3</code>在每次循环迭代的末尾执行，用于更新值。</p>
<p>注意，循环条件放在双重圆括号之中。另外，圆括号之中使用变量，不必加上美元符号<code>$</code>。</p>
<p>它等同于下面的<code>while</code>循环。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable"><span class="token punctuation">((</span> expression1 <span class="token punctuation">))</span></span>
<span class="token keyword">while</span> <span class="token variable"><span class="token punctuation">((</span> expression2 <span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  commands
  <span class="token variable"><span class="token punctuation">((</span> expression3 <span class="token punctuation">))</span></span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面是一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token variable">$i</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，初始化变量<code>i</code>的值为0，循环执行的条件是<code>i</code>小于5。每次循环迭代结束时，<code>i</code>的值加1。</p>
<p><code>for</code>条件部分的三个语句，都可以省略。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
  <span class="token builtin class-name">read</span> var
  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$var</span>"</span> <span class="token operator">=</span> <span class="token string">"."</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">break</span>
  <span class="token keyword">fi</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面脚本会反复读取命令行输入，直到用户输入了一个点（<code>.</code>）为止，才会跳出循环。</p>
<h2 id="break，continue"><a href="#break，continue" class="headerlink" title="break，continue"></a>break，continue</h2><p>Bash 提供了两个内部命令<code>break</code>和<code>continue</code>，用来在循环内部跳出循环。</p>
<p><code>break</code>命令立即终止循环，程序继续执行循环块之后的语句，即不再执行剩下的循环。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">for</span> <span class="token for-or-select variable">number</span> <span class="token keyword">in</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span>
<span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"number is <span class="token variable">$number</span>"</span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$number</span>"</span> <span class="token operator">=</span> <span class="token string">"3"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">break</span>
  <span class="token keyword">fi</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子只会打印3行结果。一旦变量<code>$number</code>等于3，就会跳出循环，不再继续执行。</p>
<p><code>continue</code>命令立即终止本轮循环，开始执行下一轮循环。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">while</span> <span class="token builtin class-name">read</span> -p <span class="token string">"What file do you want to test?"</span> filename
<span class="token keyword">do</span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -e <span class="token string">"<span class="token variable">$filename</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"The file does not exist."</span>
    <span class="token builtin class-name">continue</span>
  <span class="token keyword">fi</span>

  <span class="token builtin class-name">echo</span> <span class="token string">"You entered a valid file.."</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，只要用户输入的文件不存在，<code>continue</code>命令就会生效，直接进入下一轮循环（让用户重新输入文件名），不再执行后面的打印语句。</p>
<h2 id="select-结构"><a href="#select-结构" class="headerlink" title="select 结构"></a>select 结构</h2><p><code>select</code>结构主要用来生成简单的菜单。它的语法与<code>for...in</code>循环基本一致。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">select</span> name
<span class="token punctuation">[</span>in list<span class="token punctuation">]</span>
<span class="token keyword">do</span>
  commands
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Bash 会对<code>select</code>依次进行下面的处理。</p>
<ol>
<li><code>select</code>生成一个菜单，内容是列表<code>list</code>的每一项，并且每一项前面还有一个数字编号。</li>
<li>Bash 提示用户选择一项，输入它的编号。</li>
<li>用户输入以后，Bash 会将该项的内容存在变量<code>name</code>，该项的编号存入环境变量<code>REPLY</code>。如果用户没有输入，就按回车键，Bash 会重新输出菜单，让用户选择。</li>
<li>执行命令体<code>commands</code>。</li>
<li>执行结束后，回到第一步，重复这个过程。</li>
</ol>
<p>下面是一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># select.sh</span>

<span class="token keyword">select</span> <span class="token for-or-select variable">brand</span> <span class="token keyword">in</span> Samsung Sony iphone symphony Walton
<span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"You have chosen <span class="token variable">$brand</span>"</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行上面的脚本，Bash 会输出一个品牌的列表，让用户选择。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./select.sh
<span class="token number">1</span><span class="token punctuation">)</span> Samsung
<span class="token number">2</span><span class="token punctuation">)</span> Sony
<span class="token number">3</span><span class="token punctuation">)</span> iphone
<span class="token number">4</span><span class="token punctuation">)</span> symphony
<span class="token number">5</span><span class="token punctuation">)</span> Walton
<span class="token comment">#?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果用户没有输入编号，直接按回车键。Bash 就会重新输出一遍这个菜单，直到用户按下<code>Ctrl + c</code>，退出执行。</p>
<p><code>select</code>可以与<code>case</code>结合，针对不同项，执行不同的命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">echo</span> <span class="token string">"Which Operating System do you like?"</span>

<span class="token keyword">select</span> <span class="token for-or-select variable">os</span> <span class="token keyword">in</span> Ubuntu LinuxMint Windows8 Windows10 WindowsXP
<span class="token keyword">do</span>
  <span class="token keyword">case</span> <span class="token variable">$os</span> <span class="token keyword">in</span>
    <span class="token string">"Ubuntu"</span><span class="token operator">|</span><span class="token string">"LinuxMint"</span><span class="token punctuation">)</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"I also use <span class="token variable">$os</span>."</span>
    <span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token string">"Windows8"</span> <span class="token operator">|</span> <span class="token string">"Windows10"</span> <span class="token operator">|</span> <span class="token string">"WindowsXP"</span><span class="token punctuation">)</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"Why don't you try Linux?"</span>
    <span class="token punctuation">;</span><span class="token punctuation">;</span>
    *<span class="token punctuation">)</span>
      <span class="token builtin class-name">echo</span> <span class="token string">"Invalid entry."</span>
      <span class="token builtin class-name">break</span>
    <span class="token punctuation">;</span><span class="token punctuation">;</span>
  <span class="token keyword">esac</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>case</code>针对用户选择的不同项，执行不同的命令。</p>
<h2 id="参考链接-3"><a href="#参考链接-3" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://linuxhint.com/bash_select_command/">Bash Select Command</a>, Fahmida Yesmin</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>本章介绍 Bash 函数的用法。</p>
<h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p>函数（function）是可以重复使用的代码片段，有利于代码的复用。它与别名（alias）的区别是，别名只适合封装简单的单个命令，函数则可以封装复杂的多行命令。</p>
<p>函数总是在当前 Shell 执行，这是跟脚本的一个重大区别，Bash 会新建一个子 Shell 执行脚本。如果函数与脚本同名，函数会优先执行。但是，函数的优先级不如别名，即如果函数与别名同名，那么别名优先执行。</p>
<p>Bash 函数定义的语法有两种。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 第一种</span>
<span class="token function-name function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment"># codes</span>
<span class="token punctuation">&#125;</span>

<span class="token comment"># 第二种</span>
<span class="token keyword">function</span> <span class="token function-name function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment"># codes</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>fn</code>是自定义的函数名，函数代码就写在大括号之中。这两种写法是等价的。</p>
<p>下面是一个简单函数的例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function-name function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Hello <span class="token variable">$1</span>"</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，函数体里面的<code>$1</code>表示函数调用时的第一个参数。</p>
<p>调用时，就直接写函数名，参数跟在函数名后面。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hello world
Hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>下面是一个多行函数的例子，显示当前日期时间。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function-name function">today</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin class-name">echo</span> -n <span class="token string">"Today's date is: "</span>
  <span class="token function">date</span> +<span class="token string">"%A, %B %-d, %Y"</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>删除一个函数，可以使用<code>unset</code>命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">unset</span> -f functionName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查看当前 Shell 已经定义的所有函数，可以使用<code>declare</code>命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的<code>declare</code>命令不仅会输出函数名，还会输出所有定义。输出顺序是按照函数名的字母表顺序。由于会输出很多内容，最好通过管道命令配合<code>more</code>或<code>less</code>使用。</p>
<p><code>declare</code>命令还支持查看单个函数的定义。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -f functionName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>declare -F</code>可以输出所有已经定义的函数名，不含函数体。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -F<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h2><p>函数体内可以使用参数变量，获取函数参数。函数的参数变量，与脚本参数变量是一致的。</p>
<ul>
<li><code>$1</code>~<code>$9</code>：函数的第一个到第9个的参数。</li>
<li><code>$0</code>：函数所在的脚本名。</li>
<li><code>$#</code>：函数的参数总数。</li>
<li><code>$@</code>：函数的全部参数，参数之间使用空格分隔。</li>
<li><code>$*</code>：函数的全部参数，参数之间使用变量<code>$IFS</code>值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果函数的参数多于9个，那么第10个参数可以用<code>$&#123;10&#125;</code>的形式引用，以此类推。</p>
<p>下面是一个示例脚本<code>test.sh</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># test.sh</span>

<span class="token keyword">function</span> <span class="token function-name function">alice</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"alice: <span class="token variable">$@</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$0</span>: <span class="token variable">$1</span> <span class="token variable">$2</span> <span class="token variable">$3</span> <span class="token variable">$4</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$#</span> arguments"</span>

<span class="token punctuation">&#125;</span>

alice <span class="token keyword">in</span> wonderland<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行该脚本，结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> test.sh
alice: <span class="token keyword">in</span> wonderland
test.sh: <span class="token keyword">in</span> wonderland
<span class="token number">2</span> arguments<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，由于函数<code>alice</code>只有第一个和第二个参数，所以第三个和第四个参数为空。</p>
<p>下面是一个日志函数的例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">function</span> <span class="token function-name function">log_msg</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"[<span class="token variable"><span class="token variable">`</span><span class="token function">date</span> <span class="token string">'+ %F %T'</span><span class="token variable">`</span></span> ]: <span class="token variable">$@</span>"</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>使用方法如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ log_msg <span class="token string">"This is sample log message"</span>
<span class="token punctuation">[</span> <span class="token number">2018</span>-08-16 <span class="token number">19</span>:56:34 <span class="token punctuation">]</span>: This is sample log message<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="return-命令"><a href="#return-命令" class="headerlink" title="return 命令"></a>return 命令</h2><p><code>return</code>命令用于从函数返回一个值。函数执行到这条命令，就不再往下执行了，直接返回了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">function</span> <span class="token function-name function">func_return_value</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin class-name">return</span> <span class="token number">10</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>函数将返回值返回给调用者。如果命令行直接执行函数，下一个命令可以用<code>$?</code>拿到返回值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ func_return_value
$ <span class="token builtin class-name">echo</span> <span class="token string">"Value returned by function is: <span class="token variable">$?</span>"</span>
Value returned by <span class="token keyword">function</span> is: <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>return</code>后面不跟参数，只用于返回也是可以的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">function</span> <span class="token function-name function">name</span> <span class="token punctuation">&#123;</span>
  commands
  <span class="token builtin class-name">return</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="全局变量和局部变量，local-命令"><a href="#全局变量和局部变量，local-命令" class="headerlink" title="全局变量和局部变量，local 命令"></a>全局变量和局部变量，local 命令</h2><p>Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。这一点需要特别小心。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 脚本 test.sh</span>
<span class="token function-name function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">1</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"fn: foo = <span class="token variable">$foo</span>"</span>
<span class="token punctuation">&#125;</span>

fn
<span class="token builtin class-name">echo</span> <span class="token string">"global: foo = <span class="token variable">$foo</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面脚本的运行结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> test.sh
fn: foo <span class="token operator">=</span> <span class="token number">1</span>
global: foo <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，变量<code>$foo</code>是在函数<code>fn</code>内部声明的，函数体外也可以读取。</p>
<p>函数体内不仅可以声明全局变量，还可以修改全局变量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#! /bin/bash</span>
<span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">1</span>

<span class="token function-name function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">2</span>
<span class="token punctuation">&#125;</span>

fn

<span class="token builtin class-name">echo</span> <span class="token variable">$foo</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码执行后，输出的变量<code>$foo</code>值为2。</p>
<p>函数里面可以用<code>local</code>命令声明局部变量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#! /bin/bash</span>
<span class="token comment"># 脚本 test.sh</span>
<span class="token function-name function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin class-name">local</span> foo
  <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">1</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"fn: foo = <span class="token variable">$foo</span>"</span>
<span class="token punctuation">&#125;</span>

fn
<span class="token builtin class-name">echo</span> <span class="token string">"global: foo = <span class="token variable">$foo</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面脚本的运行结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> test.sh
fn: foo <span class="token operator">=</span> <span class="token number">1</span>
global: foo <span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>local</code>命令声明的<code>$foo</code>变量，只在函数体内有效，函数体外没有定义。</p>
<h2 id="参考链接-4"><a href="#参考链接-4" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.linuxtechi.com/define-use-functions-linux-shell-script/">How to define and use functions in Linux Shell Script</a>, by Pradeep Kumar</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组（array）是一个包含多个值的变量。成员的编号从0开始，数量没有上限，也没有要求成员被连续索引。</p>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>数组可以采用逐个赋值的方法创建。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ARRAY<span class="token punctuation">[</span>INDEX<span class="token punctuation">]</span><span class="token operator">=</span>value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面语法中，<code>ARRAY</code>是数组的名字，可以是任意合法的变量名。<code>INDEX</code>是一个大于或等于零的整数，也可以是算术表达式。注意数组第一个元素的下标是0， 而不是1。</p>
<p>下面创建一个三个成员的数组。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>val
$ array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>val
$ array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>数组也可以采用一次性赋值的方式创建。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">ARRAY</span><span class="token operator">=</span><span class="token punctuation">(</span>value1 value2 <span class="token punctuation">..</span>. valueN<span class="token punctuation">)</span>

<span class="token comment"># 等同于</span>

<span class="token assign-left variable">ARRAY</span><span class="token operator">=</span><span class="token punctuation">(</span>
  value1
  value2
  value3
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>采用上面方式创建数组时，可以按照默认顺序赋值，也可以在每个值前面指定位置。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">array</span><span class="token operator">=</span><span class="token punctuation">(</span>a b c<span class="token punctuation">)</span>
$ <span class="token assign-left variable">array</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>c <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>a <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token punctuation">)</span>

$ <span class="token assign-left variable">days</span><span class="token operator">=</span><span class="token punctuation">(</span>Sun Mon Tue Wed Thu Fri Sat<span class="token punctuation">)</span>
$ <span class="token assign-left variable">days</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>Sun <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>Mon <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>Tue <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span>Wed <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span>Thu <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span>Fri <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">=</span>Sat<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>只为某些值指定位置，也是可以的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">names</span><span class="token operator">=</span><span class="token punctuation">(</span>hatter <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span>duchess alice<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，<code>hatter</code>是数组的0号位置，<code>duchess</code>是5号位置，<code>alice</code>是6号位置。</p>
<p>没有赋值的数组元素的默认值是空字符串。</p>
<p>定义数组的时候，可以使用通配符。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">mp3s</span><span class="token operator">=</span><span class="token punctuation">(</span> *.mp3 <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，将当前目录的所有 MP3 文件，放进一个数组。</p>
<p>先用<code>declare -a</code>命令声明一个数组，也是可以的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -a ARRAYNAME<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>read -a</code>命令则是将用户的命令行输入，存入一个数组。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">read</span> -a dice<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令将用户的命令行输入，存入数组<code>dice</code>。</p>
<h2 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h2><h3 id="读取单个元素"><a href="#读取单个元素" class="headerlink" title="读取单个元素"></a>读取单个元素</h3><p>读取数组指定位置的成员，要使用下面的语法。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>&#125;</span>     <span class="token comment"># i 是索引</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面语法里面的大括号是必不可少的，否则 Bash 会把索引部分<code>[i]</code>按照原样输出。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>a

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;array<span class="token punctuation">[</span>0<span class="token punctuation">]</span>&#125;</span>
a

$ <span class="token builtin class-name">echo</span> <span class="token variable">$array</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，数组的第一个元素是<code>a</code>。如果不加大括号，Bash 会直接读取<code>$array</code>首成员的值，然后将<code>[0]</code>按照原样输出。</p>
<h3 id="读取所有成员"><a href="#读取所有成员" class="headerlink" title="读取所有成员"></a>读取所有成员</h3><p><code>@</code>和<code>*</code>是数组的特殊索引，表示返回数组的所有成员。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token punctuation">(</span>a b c d e f<span class="token punctuation">)</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>
a b c d e f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这两个特殊索引配合<code>for</code>循环，就可以用来遍历数组。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$&#123;names<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>"</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token variable">$i</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>@</code>和<code>*</code>放不放在双引号之中，是有差别的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">activities</span><span class="token operator">=</span><span class="token punctuation">(</span> swimming <span class="token string">"water skiing"</span> canoeing <span class="token string">"white-water rafting"</span> surfing <span class="token punctuation">)</span>
$ <span class="token keyword">for</span> <span class="token for-or-select variable">act</span> <span class="token keyword">in</span> <span class="token variable">$&#123;activities<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
<span class="token keyword">do</span> <span class="token punctuation">\</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Activity: <span class="token variable">$act</span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
<span class="token keyword">done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子中，数组<code>activities</code>实际包含5个成员，但是<code>for...in</code>循环直接遍历<code>$&#123;activities[@]&#125;</code>，导致返回7个结果。为了避免这种情况，一般把<code>$&#123;activities[@]&#125;</code>放在双引号之中。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">for</span> <span class="token for-or-select variable">act</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$&#123;activities<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
<span class="token keyword">do</span> <span class="token punctuation">\</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Activity: <span class="token variable">$act</span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
<span class="token keyword">done</span>

Activity: swimming
Activity: water skiing
Activity: canoeing
Activity: white-water rafting
Activity: surfing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>$&#123;activities[@]&#125;</code>放在双引号之中，遍历就会返回正确的结果。</p>
<p><code>$&#123;activities[*]&#125;</code>不放在双引号之中，跟<code>$&#123;activities[@]&#125;</code>不放在双引号之中是一样的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">for</span> <span class="token for-or-select variable">act</span> <span class="token keyword">in</span> <span class="token variable">$&#123;activities<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
<span class="token keyword">do</span> <span class="token punctuation">\</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Activity: <span class="token variable">$act</span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
<span class="token keyword">done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>$&#123;activities[*]&#125;</code>放在双引号之中，所有成员就会变成单个字符串返回。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token keyword">for</span> <span class="token for-or-select variable">act</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$&#123;activities<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
<span class="token keyword">do</span> <span class="token punctuation">\</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Activity: <span class="token variable">$act</span>"</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
<span class="token keyword">done</span>

Activity: swimming water skiing canoeing white-water rafting surfing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>所以，拷贝一个数组的最方便方法，就是写成下面这样。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">hobbies</span><span class="token operator">=</span><span class="token punctuation">(</span> <span class="token string">"<span class="token variable">$&#123;activities<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>"</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，数组<code>activities</code>被拷贝给了另一个数组<code>hobbies</code>。</p>
<p>这种写法也可以用来为新数组添加成员。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">hobbies</span><span class="token operator">=</span><span class="token punctuation">(</span> <span class="token string">"<span class="token variable">$&#123;activities<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>"</span> diving <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面例子中，新数组<code>hobbies</code>在数组<code>activities</code>的所有成员之后，又添加了一个成员。</p>
<h3 id="默认位置"><a href="#默认位置" class="headerlink" title="默认位置"></a>默认位置</h3><p>如果读取数组成员时，没有读取指定哪一个位置的成员，默认使用<code>0</code>号位置。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">declare</span> -a foo
$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>A
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token punctuation">[</span>0<span class="token punctuation">]</span>&#125;</span>
A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>foo</code>是一个数组，赋值的时候不指定位置，实际上是给<code>foo[0]</code>赋值。</p>
<p>引用一个不带下标的数组变量，则引用的是<code>0</code>号位置的数组元素。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token punctuation">(</span>a b c d e f<span class="token punctuation">)</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo&#125;</span>
a
$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，引用数组元素的时候，没有指定位置，结果返回的是<code>0</code>号位置。</p>
<h2 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h2><p>要想知道数组的长度（即一共包含多少成员），可以使用下面两种语法。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$&#123;<span class="token operator">#</span>array<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span>
<span class="token variable">$&#123;<span class="token operator">#</span>array<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>下面是一个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token operator">=</span>foo

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token operator">#</span>a<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span>
<span class="token number">1</span>

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token operator">#</span>a<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，把字符串赋值给<code>100</code>位置的数组元素，这时的数组只有一个元素。</p>
<p>注意，如果用这种语法去读取具体的数组成员，就会返回该成员的字符串长度。这一点必须小心。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token operator">=</span>foo
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token operator">#</span>a<span class="token punctuation">[</span>100<span class="token punctuation">]</span>&#125;</span>
<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>$&#123;#a[100]&#125;</code>实际上是返回数组第100号成员<code>a[100]</code>的值（<code>foo</code>）的字符串长度。</p>
<h2 id="提取数组序号"><a href="#提取数组序号" class="headerlink" title="提取数组序号"></a>提取数组序号</h2><p><code>$&#123;!array[@]&#125;</code>或<code>$&#123;!array[*]&#125;</code>，可以返回数组的成员序号，即哪些位置是有值的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">arr</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span>a <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">=</span>b <span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token operator">=</span>c<span class="token punctuation">)</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token operator">!</span>arr<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>
<span class="token number">5</span> <span class="token number">9</span> <span class="token number">23</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token operator">!</span>arr<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span>
<span class="token number">5</span> <span class="token number">9</span> <span class="token number">23</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，数组的5、9、23号位置有值。</p>
<p>利用这个语法，也可以通过<code>for</code>循环遍历数组。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">arr</span><span class="token operator">=</span><span class="token punctuation">(</span>a b c d<span class="token punctuation">)</span>

<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token variable">$&#123;<span class="token operator">!</span>arr<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span><span class="token punctuation">;</span><span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>&#125;</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="提取数组成员"><a href="#提取数组成员" class="headerlink" title="提取数组成员"></a>提取数组成员</h2><p><code>$&#123;array[@]:position:length&#125;</code>的语法可以提取数组成员。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">food</span><span class="token operator">=</span><span class="token punctuation">(</span> apples bananas cucumbers dates eggs fajitas grapes <span class="token punctuation">)</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;food<span class="token punctuation">[</span>@<span class="token punctuation">]</span><span class="token operator">:</span>1<span class="token operator">:</span>1&#125;</span>
bananas
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;food<span class="token punctuation">[</span>@<span class="token punctuation">]</span><span class="token operator">:</span>1<span class="token operator">:</span>3&#125;</span>
bananas cucumbers dates<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，<code>$&#123;food[@]:1:1&#125;</code>返回从数组1号位置开始的1个成员，<code>$&#123;food[@]:1:3&#125;</code>返回从1号位置开始的3个成员。</p>
<p>如果省略长度参数<code>length</code>，则返回从指定位置开始的所有成员。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;food<span class="token punctuation">[</span>@<span class="token punctuation">]</span><span class="token operator">:</span>4&#125;</span>
eggs fajitas grapes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子返回从4号位置开始到结束的所有成员。</p>
<h2 id="追加数组成员"><a href="#追加数组成员" class="headerlink" title="追加数组成员"></a>追加数组成员</h2><p>数组末尾追加成员，可以使用<code>+=</code>赋值运算符。它能够自动地把值追加到数组末尾。否则，就需要知道数组的最大序号，比较麻烦。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token punctuation">(</span>a b c<span class="token punctuation">)</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>
a b c

$ <span class="token assign-left variable">foo</span><span class="token operator">+=</span><span class="token punctuation">(</span>d e f<span class="token punctuation">)</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>
a b c d e f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="删除数组"><a href="#删除数组" class="headerlink" title="删除数组"></a>删除数组</h2><p>删除一个数组成员，使用<code>unset</code>命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token punctuation">(</span>a b c d e f<span class="token punctuation">)</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>
a b c d e f

$ <span class="token builtin class-name">unset</span> foo<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>
a b d e f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，删除了数组中的第三个元素，下标为2。</p>
<p>将某个成员设为空值，可以从返回值中“隐藏”这个成员。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token punctuation">(</span>a b c d e f<span class="token punctuation">)</span>
$ foo<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">''</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>
a c d e f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，将数组的第二个成员设为空字符串，数组的返回值中，这个成员就“隐藏”了。</p>
<p>注意，这里是“隐藏”，而不是删除，因为这个成员仍然存在，只是值变成了空值。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token punctuation">(</span>a b c d e f<span class="token punctuation">)</span>
$ foo<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">''</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token operator">#</span>foo<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>
<span class="token number">6</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token operator">!</span>foo<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>
<span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，第二个成员设为空值后，数组仍然包含6个成员。</p>
<p>由于空值就是空字符串，所以下面这样写也有隐藏效果，但是不建议这种写法。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ foo<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的写法也相当于“隐藏”了数组的第二个成员。</p>
<p>直接将数组变量赋值为空字符串，相当于“隐藏”数组的第一个成员。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token punctuation">(</span>a b c d e f<span class="token punctuation">)</span>
$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token string">''</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;foo<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>
b c d e f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的写法相当于“隐藏”了数组的第一个成员。</p>
<p><code>unset ArrayName</code>可以清空整个数组。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">unset</span> ARRAY

$ <span class="token builtin class-name">echo</span> <span class="token variable">$&#123;ARRAY<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span>
<span class="token operator">&lt;</span>--no output--<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h2><p>Bash 的新版本支持关联数组。关联数组使用字符串而不是整数作为数组索引。</p>
<p><code>declare -A</code>可以声明关联数组。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">declare</span> -A colors
colors<span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"#ff0000"</span>
colors<span class="token punctuation">[</span><span class="token string">"green"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"#00ff00"</span>
colors<span class="token punctuation">[</span><span class="token string">"blue"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"#0000ff"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>关联数组必须用带有<code>-A</code>选项的<code>declare</code>命令声明创建。相比之下，整数索引的数组，可以直接使用变量名创建数组，关联数组就不行。</p>
<p>访问关联数组成员的方式，几乎与整数索引数组相同。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;colors<span class="token punctuation">[</span>"blue"<span class="token punctuation">]</span>&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="set-命令，shopt-命令"><a href="#set-命令，shopt-命令" class="headerlink" title="set 命令，shopt 命令"></a>set 命令，shopt 命令</h1><p><code>set</code>命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍<code>set</code>的基本用法，帮助你写出更安全的 Bash 脚本。</p>
<h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><p>我们知道，Bash 执行脚本时，会创建一个子 Shell。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> script.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面代码中，<code>script.sh</code>是在一个子 Shell 里面执行。这个子 Shell 就是脚本的执行环境，Bash 默认给定了这个环境的各种参数。</p>
<p><code>set</code>命令用来修改子 Shell 环境的运行参数，即定制环境。一共有十几个参数可以定制，<a target="_blank" rel="noopener" href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html">官方手册</a>有完整清单，本章介绍其中最常用的几个。</p>
<p>顺便提一下，如果命令行下不带任何参数，直接运行<code>set</code>，会显示所有的环境变量和 Shell 函数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">set</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="set-u"><a href="#set-u" class="headerlink" title="set -u"></a>set -u</h2><p>执行脚本时，如果遇到不存在的变量，Bash 默认忽略它。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bash</span>

<span class="token builtin class-name">echo</span> <span class="token variable">$a</span>
<span class="token builtin class-name">echo</span> bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>$a</code>是一个不存在的变量。执行结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> script.sh

bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>可以看到，<code>echo $a</code>输出了一个空行，Bash 忽略了不存在的<code>$a</code>，然后继续执行<code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p>
<p><code>set -u</code>就用来改变这种行为。脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bash</span>
<span class="token builtin class-name">set</span> -u

<span class="token builtin class-name">echo</span> <span class="token variable">$a</span>
<span class="token builtin class-name">echo</span> bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> script.sh
bash: script.sh:行4: a: 未绑定的变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到，脚本报错了，并且不再执行后面的语句。</p>
<p><code>-u</code>还有另一种写法<code>-o nounset</code>，两者是等价的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> -o nounset<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="set-x"><a href="#set-x" class="headerlink" title="set -x"></a>set -x</h2><p>默认情况下，脚本执行后，只输出运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。</p>
<p><code>set -x</code>用来在运行结果之前，先输出执行的那一行命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bash</span>
<span class="token builtin class-name">set</span> -x

<span class="token builtin class-name">echo</span> bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行上面的脚本，结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> script.sh
+ <span class="token builtin class-name">echo</span> bar
bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>可以看到，执行<code>echo bar</code>之前，该命令会先打印出来，行首以<code>+</code>表示。这对于调试复杂的脚本是很有用的。</p>
<p><code>-x</code>还有另一种写法<code>-o xtrace</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> -o xtrace<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>脚本当中如果要关闭命令输出，可以使用<code>set +x</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token number">1</span>

<span class="token builtin class-name">set</span> -x
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$number</span> <span class="token operator">=</span> <span class="token string">"1"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Number equals 1"</span>
<span class="token keyword">else</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Number does not equal 1"</span>
<span class="token keyword">fi</span>
<span class="token builtin class-name">set</span> +x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子中，只对特定的代码段打开命令输出。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果脚本里面有运行失败的命令（返回值非<code>0</code>），Bash 默认会继续执行后面的命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bash</span>

foo
<span class="token builtin class-name">echo</span> bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面脚本中，<code>foo</code>是一个不存在的命令，执行时会报错。但是，Bash 会忽略这个错误，继续往下执行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> script.sh
script.sh:行3: foo: 未找到命令
bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>可以看到，Bash 只是显示有错误，并没有终止执行。</p>
<p>这种行为很不利于脚本安全和除错。实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的写法表示只要<code>command</code>有非零返回值，脚本就会停止执行。</p>
<p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 写法一</span>
<span class="token builtin class-name">command</span> <span class="token operator">||</span> <span class="token punctuation">&#123;</span> <span class="token builtin class-name">echo</span> <span class="token string">"command failed"</span><span class="token punctuation">;</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

<span class="token comment"># 写法二</span>
<span class="token keyword">if</span> <span class="token operator">!</span> <span class="token builtin class-name">command</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"command failed"</span><span class="token punctuation">;</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>

<span class="token comment"># 写法三</span>
<span class="token builtin class-name">command</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$?</span>"</span> -ne <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">"command failed"</span><span class="token punctuation">;</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">command1 <span class="token operator">&amp;&amp;</span> command2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="set-e"><a href="#set-e" class="headerlink" title="set -e"></a>set -e</h2><p>上面这些写法多少有些麻烦，容易疏忽。<code>set -e</code>从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bash</span>
<span class="token builtin class-name">set</span> -e

foo
<span class="token builtin class-name">echo</span> bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> script.sh
script.sh:行4: foo: 未找到命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到，第4行执行失败以后，脚本就终止执行了。</p>
<p><code>set -e</code>根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭<code>set -e</code>，该命令执行结束后，再重新打开<code>set -e</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> +e
command1
command2
<span class="token builtin class-name">set</span> -e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>set +e</code>表示关闭<code>-e</code>选项，<code>set -e</code>表示重新打开<code>-e</code>选项。</p>
<p>还有一种方法是使用<code>command || true</code>，使得该命令即使执行失败，脚本也不会终止执行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">set</span> -e

foo <span class="token operator">||</span> <span class="token boolean">true</span>
<span class="token builtin class-name">echo</span> bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>true</code>使得这一行语句总是会执行成功，后面的<code>echo bar</code>会执行。</p>
<p><code>-e</code>还有另一种写法<code>-o errexit</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> -o errexit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="set-o-pipefail"><a href="#set-o-pipefail" class="headerlink" title="set -o pipefail"></a>set -o pipefail</h2><p><code>set -e</code>有一个例外情况，就是不适用于管道命令。</p>
<p>所谓管道命令，就是多个子命令通过管道运算符（<code>|</code>）组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code>就失效了。</p>
<p>请看下面这个例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bash</span>
<span class="token builtin class-name">set</span> -e

foo <span class="token operator">|</span> <span class="token builtin class-name">echo</span> a
<span class="token builtin class-name">echo</span> bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> script.sh
a
script.sh:行4: foo: 未找到命令
bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，<code>foo</code>是一个不存在的命令，但是<code>foo | echo a</code>这个管道命令会执行成功，导致后面的<code>echo bar</code>会继续执行。</p>
<p><code>set -o pipefail</code>用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bash</span>
<span class="token builtin class-name">set</span> -eo pipefail

foo <span class="token operator">|</span> <span class="token builtin class-name">echo</span> a
<span class="token builtin class-name">echo</span> bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行后，结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> script.sh
a
script.sh:行4: foo: 未找到命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>可以看到，<code>echo bar</code>没有执行。</p>
<h2 id="set-E"><a href="#set-E" class="headerlink" title="set -E"></a>set -E</h2><p>一旦设置了<code>-e</code>参数，会导致函数内的错误不会被<code>trap</code>命令捕获（参考《trap 命令》一章）。<code>-E</code>参数可以纠正这个行为，使得函数也能继承<code>trap</code>命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">set</span> -e

<span class="token builtin class-name">trap</span> <span class="token string">"echo ERR trap fired!"</span> ERR

<span class="token function-name function">myfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token comment"># 'foo' 是一个不存在的命令</span>
  foo
<span class="token punctuation">&#125;</span>

myfunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面示例中，<code>myfunc</code>函数内部调用了一个不存在的命令<code>foo</code>，导致执行这个函数会报错。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> test.sh
test.sh:行9: foo：未找到命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>但是，由于设置了<code>set -e</code>，函数内部的报错并没有被<code>trap</code>命令捕获，需要加上<code>-E</code>参数才可以。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token builtin class-name">set</span> -Eeuo pipefail

<span class="token builtin class-name">trap</span> <span class="token string">"echo ERR trap fired!"</span> ERR

<span class="token function-name function">myfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token comment"># 'foo' 是一个不存在的命令</span>
  foo
<span class="token punctuation">&#125;</span>

myfunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行上面这个脚本，就可以看到<code>trap</code>命令生效了。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> test.sh
test.sh:行9: foo：未找到命令
ERR <span class="token builtin class-name">trap</span> fired<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h2><p><code>set</code>命令还有一些其他参数。</p>
<ul>
<li><code>set -n</code>：等同于<code>set -o noexec</code>，不运行命令，只检查语法是否正确。</li>
<li><code>set -f</code>：等同于<code>set -o noglob</code>，表示不对通配符进行文件名扩展。</li>
<li><code>set -v</code>：等同于<code>set -o verbose</code>，表示打印 Shell 接收到的每一行输入。</li>
<li><code>set -o noclobber</code>：防止使用重定向运算符<code>&gt;</code>覆盖已经存在的文件。</li>
</ul>
<p>上面的<code>-f</code>和<code>-v</code>参数，可以分别使用<code>set +f</code>、<code>set +v</code>关闭。</p>
<h2 id="set-命令总结"><a href="#set-命令总结" class="headerlink" title="set 命令总结"></a>set 命令总结</h2><p>上面重点介绍的<code>set</code>命令的几个参数，一般都放在一起使用。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 写法一</span>
<span class="token builtin class-name">set</span> -Eeuxo pipefail

<span class="token comment"># 写法二</span>
<span class="token builtin class-name">set</span> -Eeux
<span class="token builtin class-name">set</span> -o pipefail<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这两种写法建议放在所有 Bash 脚本的头部。</p>
<p>另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> -euxo pipefail script.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="shopt-命令-1"><a href="#shopt-命令-1" class="headerlink" title="shopt 命令"></a>shopt 命令</h2><p><code>shopt</code>命令用来调整 Shell 的参数，跟<code>set</code>命令的作用很类似。之所以会有这两个类似命令的主要原因是，<code>set</code>是从 Ksh 继承的，属于 POSIX 规范的一部分，而<code>shopt</code>是 Bash 特有的。</p>
<p>直接输入<code>shopt</code>可以查看所有参数，以及它们各自打开和关闭的状态。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>shopt</code>命令后面跟着参数名，可以查询该参数是否打开。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> globstar
globstar  off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面例子表示<code>globstar</code>参数默认是关闭的。</p>
<p><strong>（1）-s</strong></p>
<p><code>-s</code>用来打开某个参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> -s optionNameHere<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>（2）-u</strong></p>
<p><code>-u</code>用来关闭某个参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> -u optionNameHere<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>举例来说，<code>histappend</code>这个参数表示退出当前 Shell 时，将操作历史追加到历史文件中。这个参数默认是打开的，如果使用下面的命令将其关闭，那么当前 Shell 的操作历史将替换掉整个历史文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> -u histappend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>（3）-q</strong></p>
<p><code>-q</code>的作用也是查询某个参数是否打开，但不是直接输出查询结果，而是通过命令的执行状态（<code>$?</code>）表示查询结果。如果状态为<code>0</code>，表示该参数打开；如果为<code>1</code>，表示该参数关闭。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">shopt</span> -q globstar
$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面命令查询<code>globstar</code>参数是否打开。返回状态为<code>1</code>，表示该参数是关闭的。</p>
<p>这个用法主要用于脚本，供<code>if</code>条件结构使用。下面例子是如果打开了这个参数，就执行<code>if</code>结构内部的语句。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token operator">!</span><span class="token punctuation">(</span>shopt -q globstar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token punctuation">..</span>.
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="参考链接-5"><a href="#参考链接-5" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html">The Set Builtin</a></li>
<li><a target="_blank" rel="noopener" href="https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/">Safer bash scripts with ‘set -euxo pipefail’</a></li>
<li><a target="_blank" rel="noopener" href="http://www.davidpashley.com/articles/writing-robust-shell-scripts/">Writing Robust Bash Shell Scripts</a></li>
</ul>
<h1 id="脚本除错"><a href="#脚本除错" class="headerlink" title="脚本除错"></a>脚本除错</h1><p>本章介绍如何对 Shell 脚本除错。</p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>编写 Shell 脚本的时候，一定要考虑到命令失败的情况，否则很容易出错。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#! /bin/bash</span>

<span class="token assign-left variable">dir_name</span><span class="token operator">=</span>/path/not/exist

<span class="token builtin class-name">cd</span> <span class="token variable">$dir_name</span>
<span class="token function">rm</span> *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面脚本中，如果目录<code>$dir_name</code>不存在，<code>cd $dir_name</code>命令就会执行失败。这时，就不会改变当前目录，脚本会继续执行下去，导致<code>rm *</code>命令删光当前目录的文件。</p>
<p>如果改成下面的样子，也会有问题。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token variable">$dir_name</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面脚本中，只有<code>cd $dir_name</code>执行成功，才会执行<code>rm *</code>。但是，如果变量<code>$dir_name</code>为空，<code>cd</code>就会进入用户主目录，从而删光用户主目录的文件。</p>
<p>下面的写法才是正确的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token punctuation">[</span> -d <span class="token variable">$dir_name</span> <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> <span class="token variable">$dir_name</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面代码中，先判断目录<code>$dir_name</code>是否存在，然后才执行其他操作。</p>
<p>如果不放心删除什么文件，可以先打印出来看一下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token punctuation">[</span> -d <span class="token variable">$dir_name</span> <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> <span class="token variable">$dir_name</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> <span class="token function">rm</span> *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令中，<code>echo rm *</code>不会删除文件，只会打印出来要删除的文件。</p>
<h2 id="bash的-x参数"><a href="#bash的-x参数" class="headerlink" title="bash的-x参数"></a><code>bash</code>的<code>-x</code>参数</h2><p><code>bash</code>的<code>-x</code>参数可以在执行每一行命令之前，打印该命令。一旦出错，这样就比较容易追查。</p>
<p>下面是一个脚本<code>script.sh</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># script.sh</span>
<span class="token builtin class-name">echo</span> hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>加上<code>-x</code>参数，执行每条命令之前，都会显示该命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> -x script.sh
+ <span class="token builtin class-name">echo</span> hello world
hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，行首为<code>+</code>的行，显示该行是所要执行的命令，下一行才是该命令的执行结果。</p>
<p>下面再看一个<code>-x</code>写在脚本内部的例子。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#! /bin/bash -x</span>
<span class="token comment"># trouble: script to demonstrate common errors</span>

<span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$number</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Number is equal to 1."</span>
<span class="token keyword">else</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Number is not equal to 1."</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的脚本执行之后，会输出每一行命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ trouble
+ <span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token number">1</span>
+ <span class="token string">'['</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token string">']'</span>
+ <span class="token builtin class-name">echo</span> <span class="token string">'Number is equal to 1.'</span>
Number is equal to <span class="token number">1</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出的命令之前的<code>+</code>号，是由系统变量<code>PS4</code>决定，可以修改这个变量。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PS4</span></span><span class="token operator">=</span><span class="token string">'<span class="token variable">$LINENO</span> + '</span>
$ trouble
<span class="token number">5</span> + <span class="token assign-left variable">number</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token number">7</span> + <span class="token string">'['</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token string">']'</span>
<span class="token number">8</span> + <span class="token builtin class-name">echo</span> <span class="token string">'Number is equal to 1.'</span>
Number is equal to <span class="token number">1</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>另外，<code>set</code>命令也可以设置 Shell 的行为参数，有利于脚本除错，详见《set 命令》一章。</p>
<h2 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h2><p>有一些环境变量常用于除错。</p>
<h3 id="LINENO"><a href="#LINENO" class="headerlink" title="LINENO"></a>LINENO</h3><p>变量<code>LINENO</code>返回它在脚本里面的行号。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">echo</span> <span class="token string">"This is line <span class="token variable">$LINENO</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>执行上面的脚本<code>test.sh</code>，<code>$LINENO</code>会返回<code>3</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./test.sh
This is line <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="FUNCNAME"><a href="#FUNCNAME" class="headerlink" title="FUNCNAME"></a>FUNCNAME</h3><p>变量<code>FUNCNAME</code>返回一个数组，内容是当前的函数调用堆栈。该数组的0号成员是当前调用的函数，1号成员是调用当前函数的函数，以此类推。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">function</span> <span class="token function-name function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func1: FUNCNAME0 is <span class="token variable">$&#123;FUNCNAME<span class="token punctuation">[</span>0<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func1: FUNCNAME1 is <span class="token variable">$&#123;FUNCNAME<span class="token punctuation">[</span>1<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func1: FUNCNAME2 is <span class="token variable">$&#123;FUNCNAME<span class="token punctuation">[</span>2<span class="token punctuation">]</span>&#125;</span>"</span>
  func2
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function-name function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func2: FUNCNAME0 is <span class="token variable">$&#123;FUNCNAME<span class="token punctuation">[</span>0<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func2: FUNCNAME1 is <span class="token variable">$&#123;FUNCNAME<span class="token punctuation">[</span>1<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func2: FUNCNAME2 is <span class="token variable">$&#123;FUNCNAME<span class="token punctuation">[</span>2<span class="token punctuation">]</span>&#125;</span>"</span>
<span class="token punctuation">&#125;</span>

func1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行上面的脚本<code>test.sh</code>，结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./test.sh
func1: FUNCNAME0 is func1
func1: FUNCNAME1 is main
func1: FUNCNAME2 is
func2: FUNCNAME0 is func2
func2: FUNCNAME1 is func1
func2: FUNCNAME2 is main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，执行<code>func1</code>时，变量<code>FUNCNAME</code>的0号成员是<code>func1</code>，1号成员是调用<code>func1</code>的主脚本<code>main</code>。执行<code>func2</code>时，变量<code>FUNCNAME</code>的0号成员是<code>func2</code>，1号成员是调用<code>func2</code>的<code>func1</code>。</p>
<h3 id="BASH-SOURCE"><a href="#BASH-SOURCE" class="headerlink" title="BASH_SOURCE"></a>BASH_SOURCE</h3><p>变量<code>BASH_SOURCE</code>返回一个数组，内容是当前的脚本调用堆栈。该数组的0号成员是当前执行的脚本，1号成员是调用当前脚本的脚本，以此类推，跟变量<code>FUNCNAME</code>是一一对应关系。</p>
<p>下面有两个子脚本<code>lib1.sh</code>和<code>lib2.sh</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># lib1.sh</span>
<span class="token keyword">function</span> <span class="token function-name function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func1: BASH_SOURCE0 is <span class="token variable">$&#123;<span class="token environment constant">BASH_SOURCE</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func1: BASH_SOURCE1 is <span class="token variable">$&#123;<span class="token environment constant">BASH_SOURCE</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func1: BASH_SOURCE2 is <span class="token variable">$&#123;<span class="token environment constant">BASH_SOURCE</span><span class="token punctuation">[</span>2<span class="token punctuation">]</span>&#125;</span>"</span>
  func2
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># lib2.sh</span>
<span class="token keyword">function</span> <span class="token function-name function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func2: BASH_SOURCE0 is <span class="token variable">$&#123;<span class="token environment constant">BASH_SOURCE</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func2: BASH_SOURCE1 is <span class="token variable">$&#123;<span class="token environment constant">BASH_SOURCE</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func2: BASH_SOURCE2 is <span class="token variable">$&#123;<span class="token environment constant">BASH_SOURCE</span><span class="token punctuation">[</span>2<span class="token punctuation">]</span>&#125;</span>"</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后，主脚本<code>main.sh</code>调用上面两个子脚本。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># main.sh</span>

<span class="token builtin class-name">source</span> lib1.sh
<span class="token builtin class-name">source</span> lib2.sh

func1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行主脚本<code>main.sh</code>，会得到下面的结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./main.sh
func1: BASH_SOURCE0 is lib1.sh
func1: BASH_SOURCE1 is ./main.sh
func1: BASH_SOURCE2 is
func2: BASH_SOURCE0 is lib2.sh
func2: BASH_SOURCE1 is lib1.sh
func2: BASH_SOURCE2 is ./main.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，执行函数<code>func1</code>时，变量<code>BASH_SOURCE</code>的0号成员是<code>func1</code>所在的脚本<code>lib1.sh</code>，1号成员是主脚本<code>main.sh</code>；执行函数<code>func2</code>时，变量<code>BASH_SOURCE</code>的0号成员是<code>func2</code>所在的脚本<code>lib2.sh</code>，1号成员是调用<code>func2</code>的脚本<code>lib1.sh</code>。</p>
<h3 id="BASH-LINENO"><a href="#BASH-LINENO" class="headerlink" title="BASH_LINENO"></a>BASH_LINENO</h3><p>变量<code>BASH_LINENO</code>返回一个数组，内容是每一轮调用对应的行号。<code>$&#123;BASH_LINENO[$i]&#125;</code>跟<code>$&#123;FUNCNAME[$i]&#125;</code>是一一对应关系，表示<code>$&#123;FUNCNAME[$i]&#125;</code>在调用它的脚本文件<code>$&#123;BASH_SOURCE[$i+1]&#125;</code>里面的行号。</p>
<p>下面有两个子脚本<code>lib1.sh</code>和<code>lib2.sh</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># lib1.sh</span>
<span class="token keyword">function</span> <span class="token function-name function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func1: BASH_LINENO is <span class="token variable">$&#123;<span class="token environment constant">BASH_LINENO</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func1: FUNCNAME is <span class="token variable">$&#123;FUNCNAME<span class="token punctuation">[</span>0<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func1: BASH_SOURCE is <span class="token variable">$&#123;<span class="token environment constant">BASH_SOURCE</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>&#125;</span>"</span>

  func2
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># lib2.sh</span>
<span class="token keyword">function</span> <span class="token function-name function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func2: BASH_LINENO is <span class="token variable">$&#123;<span class="token environment constant">BASH_LINENO</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func2: FUNCNAME is <span class="token variable">$&#123;FUNCNAME<span class="token punctuation">[</span>0<span class="token punctuation">]</span>&#125;</span>"</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"func2: BASH_SOURCE is <span class="token variable">$&#123;<span class="token environment constant">BASH_SOURCE</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>&#125;</span>"</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后，主脚本<code>main.sh</code>调用上面两个子脚本。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># main.sh</span>

<span class="token builtin class-name">source</span> lib1.sh
<span class="token builtin class-name">source</span> lib2.sh

func1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行主脚本<code>main.sh</code>，会得到下面的结果。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./main.sh
func1: <span class="token environment constant">BASH_LINENO</span> is <span class="token number">7</span>
func1: FUNCNAME is func1
func1: <span class="token environment constant">BASH_SOURCE</span> is main.sh
func2: <span class="token environment constant">BASH_LINENO</span> is <span class="token number">8</span>
func2: FUNCNAME is func2
func2: <span class="token environment constant">BASH_SOURCE</span> is lib1.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，函数<code>func1</code>是在<code>main.sh</code>的第7行调用，函数<code>func2</code>是在<code>lib1.sh</code>的第8行调用的。</p>
<h1 id="mktemp-命令，trap-命令"><a href="#mktemp-命令，trap-命令" class="headerlink" title="mktemp 命令，trap 命令"></a>mktemp 命令，trap 命令</h1><p>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在<code>/tmp</code>目录里面创建文件或目录，这样做有很多弊端，使用<code>mktemp</code>命令是最安全的做法。</p>
<h2 id="临时文件的安全问题"><a href="#临时文件的安全问题" class="headerlink" title="临时文件的安全问题"></a>临时文件的安全问题</h2><p>直接创建临时文件，尤其在<code>/tmp</code>目录里面，往往会导致安全问题。</p>
<p>首先，<code>/tmp</code>目录是所有人可读写的，任何用户都可以往该目录里面写文件。创建的临时文件也是所有人可读的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">touch</span> /tmp/info.txt
$ <span class="token function">ls</span> -l /tmp/info.txt
-rw-r--r-- <span class="token number">1</span> ruanyf ruanyf <span class="token number">0</span> <span class="token number">12</span>月 <span class="token number">28</span> <span class="token number">17</span>:12 /tmp/info.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面命令在<code>/tmp</code>目录直接创建文件，该文件默认是所有人可读的。</p>
<p>其次，如果攻击者知道临时文件的文件名，他可以创建符号链接，链接到临时文件，可能导致系统运行异常。攻击者也可能向脚本提供一些恶意数据。因此，临时文件最好使用不可预测、每次都不一样的文件名，防止被利用。</p>
<p>最后，临时文件使用完毕，应该删除。但是，脚本意外退出时，往往会忽略清理临时文件。</p>
<p>生成临时文件应该遵循下面的规则。</p>
<blockquote>
<ul>
<li>创建前检查文件是否已经存在。</li>
<li>确保临时文件已成功创建。</li>
<li>临时文件必须有权限的限制。</li>
<li>临时文件要使用不可预测的文件名。</li>
<li>脚本退出时，要删除临时文件（使用<code>trap</code>命令）。</li>
</ul>
</blockquote>
<h2 id="mktemp-命令的用法"><a href="#mktemp-命令的用法" class="headerlink" title="mktemp 命令的用法"></a>mktemp 命令的用法</h2><p><code>mktemp</code>命令就是为安全创建临时文件而设计的。虽然在创建临时文件之前，它不会检查临时文件是否存在，但是它支持唯一文件名和清除机制，因此可以减轻安全攻击的风险。</p>
<p>直接运行<code>mktemp</code>命令，就能生成一个临时文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mktemp
/tmp/tmp.4GcsWSG4vj

$ <span class="token function">ls</span> -l /tmp/tmp.4GcsWSG4vj
-rw------- <span class="token number">1</span> ruanyf ruanyf <span class="token number">0</span> <span class="token number">12</span>月 <span class="token number">28</span> <span class="token number">12</span>:49 /tmp/tmp.4GcsWSG4vj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面命令中，<code>mktemp</code>命令生成的临时文件名是随机的，而且权限是只有用户本人可读写。</p>
<p>Bash 脚本使用<code>mktemp</code>命令的用法如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">TMPFILE</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>mktemp<span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token string">"Our temp file is <span class="token variable">$TMPFILE</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了确保临时文件创建成功，<code>mktemp</code>命令后面最好使用 OR 运算符（<code>||</code>），保证创建失败时退出脚本。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">TMPFILE</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>mktemp<span class="token variable">)</span></span> <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Our temp file is <span class="token variable">$TMPFILE</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了保证脚本退出时临时文件被删除，可以使用<code>trap</code>命令指定退出时的清除操作。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">trap</span> <span class="token string">'rm -f "<span class="token variable">$TMPFILE</span>"'</span> EXIT

<span class="token assign-left variable">TMPFILE</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>mktemp<span class="token variable">)</span></span> <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Our temp file is <span class="token variable">$TMPFILE</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="mktemp-命令的参数"><a href="#mktemp-命令的参数" class="headerlink" title="mktemp 命令的参数"></a>mktemp 命令的参数</h2><p><code>-d</code>参数可以创建一个临时目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mktemp -d
/tmp/tmp.Wcau5UjmN6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>-p</code>参数可以指定临时文件所在的目录。默认是使用<code>$TMPDIR</code>环境变量指定的目录，如果这个变量没设置，那么使用<code>/tmp</code>目录。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mktemp -p /home/ruanyf/
/home/ruanyf/tmp.FOKEtvs2H3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>-t</code>参数可以指定临时文件的文件名模板，模板的末尾必须至少包含三个连续的<code>X</code>字符，表示随机字符，建议至少使用六个<code>X</code>。默认的文件名模板是<code>tmp.</code>后接十个随机字符。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mktemp -t mytemp.XXXXXXX
/tmp/mytemp.yZ1HgZV<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="trap-命令"><a href="#trap-命令" class="headerlink" title="trap 命令"></a>trap 命令</h2><p><code>trap</code>命令用来在 Bash 脚本中响应系统信号。</p>
<p>最常见的系统信号就是 SIGINT（中断），即按 Ctrl + C 所产生的信号。<code>trap</code>命令的<code>-l</code>参数，可以列出所有的系统信号。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">trap</span> -l
 <span class="token number">1</span><span class="token punctuation">)</span> SIGHUP	 <span class="token number">2</span><span class="token punctuation">)</span> SIGINT	 <span class="token number">3</span><span class="token punctuation">)</span> SIGQUIT	 <span class="token number">4</span><span class="token punctuation">)</span> SIGILL	 <span class="token number">5</span><span class="token punctuation">)</span> SIGTRAP
 <span class="token number">6</span><span class="token punctuation">)</span> SIGABRT	 <span class="token number">7</span><span class="token punctuation">)</span> SIGBUS	 <span class="token number">8</span><span class="token punctuation">)</span> SIGFPE	 <span class="token number">9</span><span class="token punctuation">)</span> SIGKILL	<span class="token number">10</span><span class="token punctuation">)</span> SIGUSR1
<span class="token number">11</span><span class="token punctuation">)</span> SIGSEGV	<span class="token number">12</span><span class="token punctuation">)</span> SIGUSR2	<span class="token number">13</span><span class="token punctuation">)</span> SIGPIPE	<span class="token number">14</span><span class="token punctuation">)</span> SIGALRM	<span class="token number">15</span><span class="token punctuation">)</span> SIGTERM
<span class="token number">16</span><span class="token punctuation">)</span> SIGSTKFLT	<span class="token number">17</span><span class="token punctuation">)</span> SIGCHLD	<span class="token number">18</span><span class="token punctuation">)</span> SIGCONT	<span class="token number">19</span><span class="token punctuation">)</span> SIGSTOP	<span class="token number">20</span><span class="token punctuation">)</span> SIGTSTP
<span class="token number">21</span><span class="token punctuation">)</span> SIGTTIN	<span class="token number">22</span><span class="token punctuation">)</span> SIGTTOU	<span class="token number">23</span><span class="token punctuation">)</span> SIGURG	<span class="token number">24</span><span class="token punctuation">)</span> SIGXCPU	<span class="token number">25</span><span class="token punctuation">)</span> SIGXFSZ
<span class="token number">26</span><span class="token punctuation">)</span> SIGVTALRM	<span class="token number">27</span><span class="token punctuation">)</span> SIGPROF	<span class="token number">28</span><span class="token punctuation">)</span> SIGWINCH	<span class="token number">29</span><span class="token punctuation">)</span> SIGIO	<span class="token number">30</span><span class="token punctuation">)</span> SIGPWR
<span class="token number">31</span><span class="token punctuation">)</span> SIGSYS	<span class="token number">34</span><span class="token punctuation">)</span> SIGRTMIN	<span class="token number">35</span><span class="token punctuation">)</span> SIGRTMIN+1	<span class="token number">36</span><span class="token punctuation">)</span> SIGRTMIN+2	<span class="token number">37</span><span class="token punctuation">)</span> SIGRTMIN+3
<span class="token number">38</span><span class="token punctuation">)</span> SIGRTMIN+4	<span class="token number">39</span><span class="token punctuation">)</span> SIGRTMIN+5	<span class="token number">40</span><span class="token punctuation">)</span> SIGRTMIN+6	<span class="token number">41</span><span class="token punctuation">)</span> SIGRTMIN+7	<span class="token number">42</span><span class="token punctuation">)</span> SIGRTMIN+8
<span class="token number">43</span><span class="token punctuation">)</span> SIGRTMIN+9	<span class="token number">44</span><span class="token punctuation">)</span> SIGRTMIN+10	<span class="token number">45</span><span class="token punctuation">)</span> SIGRTMIN+11	<span class="token number">46</span><span class="token punctuation">)</span> SIGRTMIN+12	<span class="token number">47</span><span class="token punctuation">)</span> SIGRTMIN+13
<span class="token number">48</span><span class="token punctuation">)</span> SIGRTMIN+14	<span class="token number">49</span><span class="token punctuation">)</span> SIGRTMIN+15	<span class="token number">50</span><span class="token punctuation">)</span> SIGRTMAX-14	<span class="token number">51</span><span class="token punctuation">)</span> SIGRTMAX-13	<span class="token number">52</span><span class="token punctuation">)</span> SIGRTMAX-12
<span class="token number">53</span><span class="token punctuation">)</span> SIGRTMAX-11	<span class="token number">54</span><span class="token punctuation">)</span> SIGRTMAX-10	<span class="token number">55</span><span class="token punctuation">)</span> SIGRTMAX-9	<span class="token number">56</span><span class="token punctuation">)</span> SIGRTMAX-8	<span class="token number">57</span><span class="token punctuation">)</span> SIGRTMAX-7
<span class="token number">58</span><span class="token punctuation">)</span> SIGRTMAX-6	<span class="token number">59</span><span class="token punctuation">)</span> SIGRTMAX-5	<span class="token number">60</span><span class="token punctuation">)</span> SIGRTMAX-4	<span class="token number">61</span><span class="token punctuation">)</span> SIGRTMAX-3	<span class="token number">62</span><span class="token punctuation">)</span> SIGRTMAX-2
<span class="token number">63</span><span class="token punctuation">)</span> SIGRTMAX-1	<span class="token number">64</span><span class="token punctuation">)</span> SIGRTMAX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>trap</code>的命令格式如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">trap</span> <span class="token punctuation">[</span>动作<span class="token punctuation">]</span> <span class="token punctuation">[</span>信号1<span class="token punctuation">]</span> <span class="token punctuation">[</span>信号2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面代码中，“动作”是一个 Bash 命令，“信号”常用的有以下几个。</p>
<blockquote>
<ul>
<li>HUP：编号1，脚本与所在的终端脱离联系。</li>
<li>INT：编号2，用户按下 Ctrl + C，意图让脚本终止运行。</li>
<li>QUIT：编号3，用户按下 Ctrl + 斜杠，意图退出脚本。</li>
<li>KILL：编号9，该信号用于杀死进程。</li>
<li>TERM：编号15，这是<code>kill</code>命令发出的默认信号。</li>
<li>EXIT：编号0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。</li>
</ul>
</blockquote>
<p><code>trap</code>命令响应<code>EXIT</code>信号的写法如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">trap</span> <span class="token string">'rm -f "<span class="token variable">$TMPFILE</span>"'</span> EXIT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面命令中，脚本遇到<code>EXIT</code>信号时，就会执行<code>rm -f &quot;$TMPFILE&quot;</code>。</p>
<p>trap 命令的常见使用场景，就是在 Bash 脚本中指定退出时执行的清理命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">trap</span> <span class="token string">'rm -f "<span class="token variable">$TMPFILE</span>"'</span> EXIT

<span class="token assign-left variable">TMPFILE</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>mktemp<span class="token variable">)</span></span> <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token function">ls</span> /etc <span class="token operator">></span> <span class="token variable">$TMPFILE</span>
<span class="token keyword">if</span> <span class="token function">grep</span> -qi <span class="token string">"kernel"</span> <span class="token variable">$TMPFILE</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">'find'</span>
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面代码中，不管是脚本正常执行结束，还是用户按 Ctrl + C 终止，都会产生<code>EXIT</code>信号，从而触发删除临时文件。</p>
<p>注意，<code>trap</code>命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。</p>
<p>如果<code>trap</code>需要触发多条命令，可以封装一个 Bash 函数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">function</span> <span class="token function-name function">egress</span> <span class="token punctuation">&#123;</span>
  command1
  command2
  command3
<span class="token punctuation">&#125;</span>

<span class="token builtin class-name">trap</span> egress EXIT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="参考链接-6"><a href="#参考链接-6" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.putorius.net/working-with-temporary-files.html">Working with Temporary Files and Directories in Shell Scripts</a>, Steven Vona</li>
<li><a target="_blank" rel="noopener" href="https://www.putorius.net/using-trap-to-exit-bash-scripts-cleanly.html">Using Trap to Exit Bash Scripts Cleanly</a></li>
<li><a target="_blank" rel="noopener" href="https://mywiki.wooledge.org/SignalTrap">Sending and Trapping Signals</a></li>
</ul>
<h1 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h1><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>用户每次使用 Shell，都会开启一个与 Shell 的 Session（对话）。</p>
<p>Session 有两种类型：登录 Session 和非登录 Session，也可以叫做 login shell 和 non-login shell。</p>
<h3 id="登录-Session"><a href="#登录-Session" class="headerlink" title="登录 Session"></a>登录 Session</h3><p>登录 Session 是用户登录系统以后，系统为用户开启的原始 Session，通常需要用户输入用户名和密码进行登录。</p>
<p>登录 Session 一般进行整个系统环境的初始化，启动的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/profile</code>：所有用户的全局配置脚本。</li>
<li><code>/etc/profile.d</code>目录里面所有<code>.sh</code>文件</li>
<li><code>~/.bash_profile</code>：用户的个人配置脚本。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.bash_login</code>：如果<code>~/.bash_profile</code>没找到，则尝试执行这个脚本（C shell 的初始化脚本）。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.profile</code>：如果<code>~/.bash_profile</code>和<code>~/.bash_login</code>都没找到，则尝试读取这个脚本（Bourne shell 和 Korn shell 的初始化脚本）。</li>
</ul>
<p>Linux 发行版更新的时候，会更新<code>/etc</code>里面的文件，比如<code>/etc/profile</code>，因此不要直接修改这个文件。如果想修改所有用户的登陆环境，就在<code>/etc/profile.d</code>目录里面新建<code>.sh</code>脚本。</p>
<p>如果想修改你个人的登录环境，一般是写在<code>~/.bash_profile</code>里面。下面是一个典型的<code>.bash_profile</code>文件。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># .bash_profile</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token environment constant">$HOME</span>/bin

<span class="token assign-left variable"><span class="token environment constant">SHELL</span></span><span class="token operator">=</span>/bin/bash
<span class="token assign-left variable">MANPATH</span><span class="token operator">=</span>/usr/man:/usr/X11/man
<span class="token assign-left variable">EDITOR</span><span class="token operator">=</span>/usr/bin/vi
<span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">'\h:\w\$ '</span>
<span class="token assign-left variable"><span class="token environment constant">PS2</span></span><span class="token operator">=</span><span class="token string">'> '</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> -f ~/.bashrc <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token builtin class-name">.</span> ~/.bashrc
<span class="token keyword">fi</span>

<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span>
<span class="token builtin class-name">export</span> EDITOR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，这个脚本定义了一些最基本的环境变量，然后执行了<code>~/.bashrc</code>。</p>
<p><code>bash</code>命令的<code>--login</code>参数，会强制执行登录 Session 会执行的脚本。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> --login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>bash</code>命令的<code>--noprofile</code>参数，会跳过上面这些 Profile 脚本。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> --noprofile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="非登录-Session"><a href="#非登录-Session" class="headerlink" title="非登录 Session"></a>非登录 Session</h3><p>非登录 Session 是用户进入系统以后，手动新建的 Session，这时不会进行环境初始化。比如，在命令行执行<code>bash</code>命令，就会新建一个非登录 Session。</p>
<p>非登录 Session 的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/bash.bashrc</code>：对全体用户有效。</li>
<li><code>~/.bashrc</code>：仅对当前用户有效。</li>
</ul>
<p>对用户来说，<code>~/.bashrc</code>通常是最重要的脚本。非登录 Session 默认会执行它，而登录 Session 一般也会通过调用执行它。每次新建一个 Bash 窗口，就相当于新建一个非登录 Session，所以<code>~/.bashrc</code>每次都会执行。注意，执行脚本相当于新建一个非互动的 Bash 环境，但是这种情况不会调用<code>~/.bashrc</code>。</p>
<p><code>bash</code>命令的<code>--norc</code>参数，可以禁止在非登录 Session 执行<code>~/.bashrc</code>脚本。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> --norc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>bash</code>命令的<code>--rcfile</code>参数，指定另一个脚本代替<code>.bashrc</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> --rcfile testrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="bash-logout"><a href="#bash-logout" class="headerlink" title=".bash_logout"></a>.bash_logout</h3><p><code>~/.bash_logout</code>脚本在每次退出 Session 时执行，通常用来做一些清理工作和记录工作，比如删除临时文件，记录用户在本次 Session 花费的时间。</p>
<p>如果没有退出时要执行的命令，这个文件也可以不存在。</p>
<h2 id="启动选项"><a href="#启动选项" class="headerlink" title="启动选项"></a>启动选项</h2><p>为了方便 Debug，有时在启动 Bash 的时候，可以加上启动参数。</p>
<ul>
<li><code>-n</code>：不运行脚本，只检查是否有语法错误。</li>
<li><code>-v</code>：输出每一行语句运行结果前，会先输出该行语句。</li>
<li><code>-x</code>：每一个命令处理之前，先输出该命令，再执行该命令。</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> -n scriptname
$ <span class="token function">bash</span> -v scriptname
$ <span class="token function">bash</span> -x scriptname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="键盘绑定"><a href="#键盘绑定" class="headerlink" title="键盘绑定"></a>键盘绑定</h2><p>Bash 允许用户定义自己的快捷键。全局的键盘绑定文件默认为<code>/etc/inputrc</code>，你可以在主目录创建自己的键盘绑定文件<code>.inputrc</code>文件。如果定义了这个文件，需要在其中加入下面这行，保证全局绑定不会被遗漏。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$include</span> /etc/inputrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>.inputrc</code>文件里面的快捷键，可以像这样定义，<code>&quot;\C-t&quot;:&quot;pwd\n&quot;</code>表示将<code>Ctrl + t</code>绑定为运行<code>pwd</code>命令。</p>
<h1 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h1><p>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。</p>
<h2 id="环境变量-PS1"><a href="#环境变量-PS1" class="headerlink" title="环境变量 PS1"></a>环境变量 PS1</h2><p>命令提示符通常是美元符号<code>$</code>，对于根用户则是井号<code>#</code>。这个符号是环境变量<code>PS1</code>决定的，执行下面的命令，可以看到当前命令提示符的定义。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PS1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Bash 允许用户自定义命令提示符，只要改写这个变量即可。改写后的<code>PS1</code>，可以放在用户的 Bash 配置文件<code>.bashrc</code>里面，以后新建 Bash 对话时，新的提示符就会生效。要在当前窗口看到修改后的提示符，可以执行下面的命令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>命令提示符的定义，可以包含特殊的转义字符，表示特定内容。</p>
<ul>
<li><code>\a</code>：响铃，计算机发出一记声音。</li>
<li><code>\d</code>：以星期、月、日格式表示当前日期，例如“Mon May 26”。</li>
<li><code>\h</code>：本机的主机名。</li>
<li><code>\H</code>：完整的主机名。</li>
<li><code>\j</code>：运行在当前 Shell 会话的工作数。</li>
<li><code>\l</code>：当前终端设备名。</li>
<li><code>\n</code>：一个换行符。</li>
<li><code>\r</code>：一个回车符。</li>
<li><code>\s</code>：Shell 的名称。</li>
<li><code>\t</code>：24小时制的<code>hours:minutes:seconds</code>格式表示当前时间。</li>
<li><code>\T</code>：12小时制的当前时间。</li>
<li><code>\@</code>：12小时制的<code>AM/PM</code>格式表示当前时间。</li>
<li><code>\A</code>：24小时制的<code>hours:minutes</code>表示当前时间。</li>
<li><code>\u</code>：当前用户名。</li>
<li><code>\v</code>：Shell 的版本号。</li>
<li><code>\V</code>：Shell 的版本号和发布号。</li>
<li><code>\w</code>：当前的工作路径。</li>
<li><code>\W</code>：当前目录名。</li>
<li><code>\!</code>：当前命令在命令历史中的编号。</li>
<li><code>\#</code>：当前 shell 会话中的命令数。</li>
<li><code>\$</code>：普通用户显示为<code>$</code>字符，根用户显示为<code>#</code>字符。</li>
<li><code>\[</code>：非打印字符序列的开始标志。</li>
<li><code>\]</code>：非打印字符序列的结束标志。</li>
</ul>
<p>举例来说，<code>[\u@\h \W]\$</code>这个提示符定义，显示出来就是<code>[user@host ~]$</code>（具体的显示内容取决于你的系统）。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>user@host ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PS1</span>
<span class="token punctuation">[</span><span class="token punctuation">\</span>u@<span class="token punctuation">\</span>h <span class="token punctuation">\</span>W<span class="token punctuation">]</span><span class="token punctuation">\</span>$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>改写<code>PS1</code>变量，就可以改变这个命令提示符。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">"\A \h \$ "</span>
<span class="token number">17</span>:33 <span class="token function">host</span> $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>注意，<code>$</code>后面最好跟一个空格，这样的话，用户的输入与提示符就不会连在一起。</p>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>默认情况下，命令提示符是显示终端预定义的颜色。Bash 允许自定义提示符颜色。</p>
<p>使用下面的代码，可以设定其后文本的颜色。</p>
<ul>
<li><code>\033[0;30m</code>：黑色</li>
<li><code>\033[1;30m</code>：深灰色</li>
<li><code>\033[0;31m</code>：红色</li>
<li><code>\033[1;31m</code>：浅红色</li>
<li><code>\033[0;32m</code>：绿色</li>
<li><code>\033[1;32m</code>：浅绿色</li>
<li><code>\033[0;33m</code>：棕色</li>
<li><code>\033[1;33m</code>：黄色</li>
<li><code>\033[0;34m</code>：蓝色</li>
<li><code>\033[1;34m</code>：浅蓝色</li>
<li><code>\033[0;35m</code>：粉红</li>
<li><code>\033[1;35m</code>：浅粉色</li>
<li><code>\033[0;36m</code>：青色</li>
<li><code>\033[1;36m</code>：浅青色</li>
<li><code>\033[0;37m</code>：浅灰色</li>
<li><code>\033[1;37m</code>：白色</li>
</ul>
<p>举例来说，如果要将提示符设为红色，可以将<code>PS1</code>设成下面的代码。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">'\[<span class="token entity" title="\033">\033</span>[0;31m\]&lt;\u@\h \W>\$'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>但是，上面这样设置以后，用户在提示符后面输入的文本也是红色的。为了解决这个问题， 可以在结尾添加另一个特殊代码<code>\[\033[00m\]</code>，表示将其后的文本恢复到默认颜色。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">'\[<span class="token entity" title="\033">\033</span>[0;31m\]&lt;\u@\h \W>\$\[<span class="token entity" title="\033">\033</span>[00m\]'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>除了设置前景颜色，Bash 还允许设置背景颜色。</p>
<ul>
<li><code>\033[0;40m</code>：蓝色</li>
<li><code>\033[1;44m</code>：黑色</li>
<li><code>\033[0;41m</code>：红色</li>
<li><code>\033[1;45m</code>：粉红</li>
<li><code>\033[0;42m</code>：绿色</li>
<li><code>\033[1;46m</code>：青色</li>
<li><code>\033[0;43m</code>：棕色</li>
<li><code>\033[1;47m</code>：浅灰色</li>
</ul>
<p>下面是一个带有红色背景的提示符。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">'\[<span class="token entity" title="\033">\033</span>[0;41m\]&lt;\u@\h \W>\$\[<span class="token entity" title="\033">\033</span>[0m\] '</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="环境变量-PS2，PS3，PS4"><a href="#环境变量-PS2，PS3，PS4" class="headerlink" title="环境变量 PS2，PS3，PS4"></a>环境变量 PS2，PS3，PS4</h2><p>除了<code>PS1</code>，Bash 还提供了提示符相关的另外三个环境变量。</p>
<p>环境变量<code>PS2</code>是命令行折行输入时系统的提示符，默认为<code>&gt; </code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"hello
> world"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面命令中，输入<code>hello</code>以后按下回车键，系统会提示继续输入。这时，第二行显示的提示符就是<code>PS2</code>定义的<code>&gt; </code>。</p>
<p>环境变量<code>PS3</code>是使用<code>select</code>命令时，系统输入菜单的提示符。</p>
<p>环境变量<code>PS4</code>默认为<code>+ </code>。它是使用 Bash 的<code>-x</code>参数执行脚本时，每一行命令在执行前都会先打印出来，并且在行首出现的那个提示符。</p>
<p>比如下面是脚本<code>test.sh</code>。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">echo</span> <span class="token string">"hello world"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>使用<code>-x</code>参数执行这个脚本。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">bash</span> -x test.sh
+ <span class="token builtin class-name">echo</span> <span class="token string">'hello world'</span>
hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面例子中，输出的第一行前面有一个<code>+ </code>，这就是变量<code>PS4</code>定义的。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://twitter.com/zheyizhifeng">
          <span class="icon">
            <i class="fab fa-twitter"></i>
          </span>

          <span class="label">Twitter</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://t.me/zheyizhifeng">
          <span class="icon">
            <i class="fab fa-telegram"></i>
          </span>

          <span class="label">Telegram</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="/images/wechat.jpg">
          <span class="icon">
            <i class="fab fa-weixin"></i>
          </span>

          <span class="label">WeChat</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Programming/" rel="tag"><i class="fa fa-tag"></i> Programming</a>
              <a href="/tags/Linux/" rel="tag"><i class="fa fa-tag"></i> Linux</a>
              <a href="/tags/Bash/" rel="tag"><i class="fa fa-tag"></i> Bash</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/10/12/Web%20API%20%E6%95%99%E7%A8%8B/" rel="prev" title="Web API 教程">
                  <i class="fa fa-chevron-left"></i> Web API 教程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/10/13/JS%20%E7%9A%84%20try%20catch%20%E8%83%BD%E6%8D%95%E8%8E%B7%E5%88%B0%E5%93%AA%E4%BA%9B%E5%BC%82%E5%B8%B8/" rel="next" title="JS 的 try catch 能捕获到哪些异常">
                  JS 的 try catch 能捕获到哪些异常 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lucida</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  





</body>
</html>
